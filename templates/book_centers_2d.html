<!DOCTYPE html>
<html lang="el" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book Centers 2D - Biofeedback Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(circle at center, #0a0a0f 0%, #000000 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui;
            height: 100vh;
            overflow: hidden;
            color: white;
            position: relative;
        }
        
        /* Main 2D Navigation Canvas */
        .navigation-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, rgba(10, 10, 15, 0.8) 0%, rgba(0, 0, 0, 0.9) 100%);
        }
        
        /* Book Centers - 2D geometric shapes */
        .center-node {
            position: absolute;
            width: 120px;
            height: 120px;
            transition: all 0.8s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 400;
            text-align: center;
            letter-spacing: 1px;
            backdrop-filter: blur(10px);
        }
        
        .center-node.active {
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.6);
            transform: scale(1.3);
        }
        
        .center-node.target {
            animation: targetPulse 2s ease-in-out infinite;
        }
        
        .center-node.unlocked {
            animation: unlockedGlow 1.5s ease-in-out infinite;
            border: 3px solid rgba(255, 255, 255, 0.8);
        }
        
        /* Specific Book Centers */
        .center-presence {
            background: radial-gradient(circle, rgba(255, 215, 0, 0.7) 0%, rgba(255, 165, 0, 0.4) 100%);
            top: 15%;
            left: 25%;
            border-radius: 50%;
            border: 3px solid rgba(255, 215, 0, 0.9);
        }
        
        .center-quality {
            background: radial-gradient(circle, rgba(138, 43, 226, 0.7) 0%, rgba(75, 0, 130, 0.4) 100%);
            top: 60%;
            left: 70%;
            clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
            border: 3px solid rgba(138, 43, 226, 0.9);
        }
        
        .center-forgiveness {
            background: radial-gradient(circle, rgba(34, 197, 94, 0.7) 0%, rgba(22, 163, 74, 0.4) 100%);
            top: 40%;
            left: 50%;
            transform: rotate(45deg);
            border: 3px solid rgba(34, 197, 94, 0.9);
        }
        
        .center-awareness {
            background: radial-gradient(circle, rgba(59, 130, 246, 0.7) 0%, rgba(29, 78, 216, 0.4) 100%);
            top: 75%;
            left: 20%;
            border-radius: 20px;
            border: 3px solid rgba(59, 130, 246, 0.9);
        }
        
        .center-compassion {
            background: radial-gradient(circle, rgba(236, 72, 153, 0.7) 0%, rgba(190, 24, 93, 0.4) 100%);
            top: 20%;
            left: 75%;
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            border: 3px solid rgba(236, 72, 153, 0.9);
        }
        
        /* YOU Orb - 2D Navigation */
        .user-orb {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.3) 100%);
            border: 4px solid rgba(255, 255, 255, 1);
            top: 45%;
            left: 8%;
            transition: all 0.3s ease;
            animation: orbPulse 3s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            z-index: 100;
            cursor: grab;
        }
        
        .user-orb:active {
            cursor: grabbing;
        }
        
        /* Biofeedback Engine Panel */
        .biofeedback-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .metric-bar {
            width: 150px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .metric-fill {
            height: 100%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }
        
        .hrv-fill { background: linear-gradient(90deg, #ff6b6b, #ff8e53); }
        .breath-fill { background: linear-gradient(90deg, #4ecdc4, #44a08d); }
        .coherence-fill { background: linear-gradient(90deg, #6c5ce7, #a29bfe); }
        .focus-fill { background: linear-gradient(90deg, #fdcb6e, #e17055); }
        
        /* Soul Metrics Panel */
        .soul-metrics-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }
        
        .soul-metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .consciousness-level {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #a29bfe;
            margin-top: 10px;
        }
        
        /* Coaching Agent Panel */
        .coaching-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 400px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }
        
        .coaching-message {
            color: #74b9ff;
            font-size: 14px;
            line-height: 1.5;
        }
        
        /* Progress Log Panel */
        .progress-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            max-height: 200px;
            overflow-y: auto;
        }
        
        .progress-item {
            font-size: 12px;
            color: #ddd;
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid #00b894;
            padding-left: 10px;
        }
        
        /* Connection Lines */
        .connection-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.6) 0%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.6) 100%);
            transform-origin: left center;
            animation: connectionFlow 3s ease-in-out infinite;
        }
        
        /* Animations */
        @keyframes targetPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 255, 0.8); }
        }
        
        @keyframes unlockedGlow {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 255, 255, 0.6); }
            50% { box-shadow: 0 0 60px rgba(255, 255, 255, 0.9); }
        }
        
        @keyframes orbPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.7); }
            50% { box-shadow: 0 0 40px rgba(255, 255, 255, 1); }
        }
        
        @keyframes connectionFlow {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }
        
        /* Hidden until needed */
        .hidden { display: none; }
    </style>
</head>
<body>
    <!-- Main 2D Navigation Canvas -->
    <div class="navigation-canvas">
        <!-- Book Centers - 2D Geometric Nodes -->
        <div class="center-node center-presence target" data-center="presence">
            <span>ΠΑΡΟΥΣΙΑ<br>PRESENCE</span>
        </div>
        
        <div class="center-node center-quality" data-center="quality">
            <span>ΠΟΙΟΤΗΤΑ<br>QUALITY</span>
        </div>
        
        <div class="center-node center-forgiveness" data-center="forgiveness">
            <span style="transform: rotate(-45deg);">ΣΥΓΧΩΡΕΣΗ<br>FORGIVENESS</span>
        </div>
        
        <div class="center-node center-awareness" data-center="awareness">
            <span>ΕΠΙΓΝΩΣΗ<br>AWARENESS</span>
        </div>
        
        <div class="center-node center-compassion" data-center="compassion">
            <span>ΣΥΜΠΟΝΙΑ<br>COMPASSION</span>
        </div>
        
        <!-- YOU Orb - 2D Navigation -->
        <div class="user-orb" id="userOrb">
            YOU
        </div>
        
        <!-- Connection Lines (drawn dynamically) -->
        <div id="connectionLines"></div>
    </div>
    
    <!-- Biofeedback Engine Panel -->
    <div class="biofeedback-panel">
        <h4 style="margin-bottom: 15px; color: #74b9ff;">🫀 Biofeedback Engine</h4>
        
        <div class="metric-row">
            <span>HRV:</span>
            <div class="metric-bar">
                <div class="metric-fill hrv-fill" id="hrvBar" style="width: 65%;"></div>
            </div>
            <span id="hrvValue">65%</span>
        </div>
        
        <div class="metric-row">
            <span>Breath Rate:</span>
            <div class="metric-bar">
                <div class="metric-fill breath-fill" id="breathBar" style="width: 72%;"></div>
            </div>
            <span id="breathValue">72%</span>
        </div>
        
        <div class="metric-row">
            <span>Coherence:</span>
            <div class="metric-bar">
                <div class="metric-fill coherence-fill" id="coherenceBar" style="width: 58%;"></div>
            </div>
            <span id="coherenceValue">58%</span>
        </div>
        
        <div class="metric-row">
            <span>Focus:</span>
            <div class="metric-bar">
                <div class="metric-fill focus-fill" id="focusBar" style="width: 80%;"></div>
            </div>
            <span id="focusValue">80%</span>
        </div>
    </div>
    
    <!-- Soul Metrics Panel -->
    <div class="soul-metrics-panel">
        <h4 style="margin-bottom: 15px; color: #a29bfe;">✨ Soul Metrics</h4>
        
        <div class="soul-metric">
            <span>Coherence:</span>
            <span id="soulCoherence">73%</span>
        </div>
        
        <div class="soul-metric">
            <span>Vitality:</span>
            <span id="soulVitality">68%</span>
        </div>
        
        <div class="soul-metric">
            <span>Ethics:</span>
            <span id="soulEthics">85%</span>
        </div>
        
        <div class="soul-metric">
            <span>Narrative:</span>
            <span id="soulNarrative">71%</span>
        </div>
        
        <div class="consciousness-level" id="consciousnessLevel">
            Developing
        </div>
    </div>
    
    <!-- Coaching Agent Panel -->
    <div class="coaching-panel">
        <h4 style="margin-bottom: 10px; color: #00b894;">🤖 Intelligent Coach</h4>
        <div class="coaching-message" id="coachingMessage">
            Your focus is strong! Try moving the orb towards the golden PRESENCE center. Breathe deeply and let your coherence guide you.
        </div>
    </div>
    
    <!-- Progress Log Panel -->
    <div class="progress-panel">
        <h4 style="margin-bottom: 10px; color: #fdcb6e;">📊 Progress Log</h4>
        <div class="progress-item">18:35 - Session started with PRESENCE center</div>
        <div class="progress-item">18:36 - HRV coherence increased to 65%</div>
        <div class="progress-item">18:36 - Focus spike detected (80%)</div>
        <div class="progress-item">18:37 - Moving towards target center...</div>
    </div>

    <script>
        // Global State Management System - Κοινό context για όλα τα modules
        class StateManager {
            constructor() {
                this.state = {
                    // Biofeedback Data
                    biofeedback: {
                        hrv: 65,
                        breath: 72,
                        coherence: 58,
                        focus: 80,
                        trends: { hrv: [], breath: [], coherence: [], focus: [] }
                    },
                    
                    // Soul Metrics
                    soulMetrics: {
                        coherence: 73,
                        vitality: 68,
                        ethics: 85,
                        narrative: 71,
                        consciousnessLevel: 'Developing'
                    },
                    
                    // Navigation & Progress
                    navigation: {
                        currentTarget: 'presence',
                        orbPosition: { x: 8, y: 45 },
                        targetDistance: 0,
                        isMoving: false,
                        unlockedCenters: [],
                        stuckCounter: 0,
                        lastMovement: Date.now()
                    },
                    
                    // User Patterns & Learning
                    userPatterns: {
                        stuckPoints: [],
                        successTriggers: [],
                        preferredNavigation: 'mixed', // 'manual', 'biofeedback', 'mixed'
                        responseToCoaching: [],
                        sessionHistory: [],
                        learningProfile: {
                            respondsTo: ['visual', 'breathing'],
                            difficulty: 'adaptive',
                            bestTimes: [],
                            optimalMetrics: {}
                        }
                    },
                    
                    // Session Data
                    session: {
                        startTime: Date.now(),
                        events: [],
                        currentPhase: 'start',
                        totalProgress: 0,
                        coachingInterventions: 0
                    }
                };
                
                this.subscribers = [];
                this.initializePatternAnalysis();
            }
            
            // Subscribe to state changes
            subscribe(callback) {
                this.subscribers.push(callback);
                return () => {
                    this.subscribers = this.subscribers.filter(sub => sub !== callback);
                };
            }
            
            // Update state and notify subscribers
            updateState(path, value) {
                const pathArray = path.split('.');
                let current = this.state;
                
                // Navigate to parent
                for (let i = 0; i < pathArray.length - 1; i++) {
                    current = current[pathArray[i]];
                }
                
                // Set value
                current[pathArray[pathArray.length - 1]] = value;
                
                // Notify subscribers
                this.subscribers.forEach(callback => callback(this.state, path, value));
            }
            
            getState(path = null) {
                if (!path) return this.state;
                
                const pathArray = path.split('.');
                let current = this.state;
                
                for (const key of pathArray) {
                    current = current[key];
                    if (current === undefined) return null;
                }
                
                return current;
            }
            
            logEvent(message, type = 'info') {
                // Simple logging without triggering state updates
                console.log(`[${type}] ${message}`);
            }
            
            // Advanced Pattern Analysis - Μαθαίνει από τον χρήστη
            analyzePatterns() {
                const bio = this.state.biofeedback;
                const nav = this.state.navigation;
                const patterns = this.state.userPatterns;
                
                // Detect stuck states
                if (nav.targetDistance > 200 && nav.stuckCounter > 5) {
                    this.detectStuckPattern();
                }
                
                // Analyze success patterns
                if (bio.coherence > 70 && bio.focus > 75) {
                    this.recordSuccessPattern();
                }
                
                // Update learning profile
                this.updateLearningProfile();
            }
            
            detectStuckPattern() {
                const stuckPoint = {
                    timestamp: Date.now(),
                    target: this.state.navigation.currentTarget,
                    metrics: { ...this.state.biofeedback },
                    orbPosition: { ...this.state.navigation.orbPosition },
                    duration: this.state.navigation.stuckCounter
                };
                
                this.state.userPatterns.stuckPoints.push(stuckPoint);
                this.logEvent(`Stuck pattern detected at ${stuckPoint.target}`, 'pattern');
                
                // Trigger intelligent coaching
                this.triggerAdaptiveCoaching();
            }
            
            recordSuccessPattern() {
                const successTrigger = {
                    timestamp: Date.now(),
                    metrics: { ...this.state.biofeedback },
                    context: this.state.navigation.currentTarget,
                    coherenceSpike: this.state.biofeedback.coherence > 75
                };
                
                this.state.userPatterns.successTriggers.push(successTrigger);
                this.logEvent(`Success pattern recorded: ${successTrigger.context}`, 'success');
            }
            
            updateLearningProfile() {
                const patterns = this.state.userPatterns;
                const profile = patterns.learningProfile;
                
                // Analyze what works for this user
                if (patterns.successTriggers.length > 3) {
                    const avgSuccessMetrics = this.calculateAverageMetrics(patterns.successTriggers);
                    profile.optimalMetrics = avgSuccessMetrics;
                }
                
                // Determine preferred navigation style
                const manualMoves = this.countManualMoves();
                const biofeedbackMoves = this.countBiofeedbackMoves();
                
                if (manualMoves > biofeedbackMoves * 2) {
                    profile.navigation = 'manual';
                } else if (biofeedbackMoves > manualMoves * 2) {
                    profile.navigation = 'biofeedback';
                } else {
                    profile.navigation = 'mixed';
                }
            }
            
            calculateAverageMetrics(triggers) {
                const avg = { hrv: 0, breath: 0, coherence: 0, focus: 0 };
                triggers.forEach(t => {
                    avg.hrv += t.metrics.hrv;
                    avg.breath += t.metrics.breath;
                    avg.coherence += t.metrics.coherence;
                    avg.focus += t.metrics.focus;
                });
                
                const count = triggers.length;
                return {
                    hrv: avg.hrv / count,
                    breath: avg.breath / count,
                    coherence: avg.coherence / count,
                    focus: avg.focus / count
                };
            }
            
            countManualMoves() {
                return this.state.session.events.filter(e => 
                    e.message.includes('Manual orb movement')).length;
            }
            
            countBiofeedbackMoves() {
                return this.state.session.events.filter(e => 
                    e.message.includes('Biofeedback navigation')).length;
            }
            
            triggerAdaptiveCoaching() {
                // Intelligent coaching based on learned patterns
                const patterns = this.state.userPatterns;
                const coachingEvent = {
                    type: 'adaptive_intervention',
                    timestamp: Date.now(),
                    trigger: 'stuck_pattern',
                    userProfile: patterns.learningProfile
                };
                
                this.updateState('session.coachingInterventions', 
                    this.state.session.coachingInterventions + 1);
                
                this.logEvent('Adaptive coaching intervention triggered', 'coaching');
            }
            
            initializePatternAnalysis() {
                // Start continuous pattern monitoring (less frequent to avoid loops)
                setInterval(() => {
                    this.monitorUserBehavior();
                }, 5000);
            }
            
            monitorUserBehavior() {
                const now = Date.now();
                const nav = this.state.navigation;
                
                // Check for movement
                if (now - nav.lastMovement > 10000) { // 10 seconds no movement
                    this.updateState('navigation.stuckCounter', nav.stuckCounter + 1);
                } else {
                    this.updateState('navigation.stuckCounter', 0);
                }
                
                // Update session progress
                const totalCenters = 5;
                const progress = (nav.unlockedCenters.length / totalCenters) * 100;
                this.updateState('session.totalProgress', progress);
            }
        }
        
        // Initialize Global State Manager
        const stateManager = new StateManager();
        
        // 2D Book Centers Biofeedback System με State Management
        class BookCenters2D {
            constructor() {
                this.userOrb = document.getElementById('userOrb');
                this.isDragging = false;
                
                // Subscribe to state changes
                stateManager.subscribe((state, path, value) => {
                    this.handleStateChange(state, path, value);
                });
                
                this.initializeOrb();
                this.startBiofeedbackSimulation();
                this.startIntelligentCoaching();
                this.drawConnectionLines();
                
                stateManager.logEvent('Book Centers 2D session started', 'session');
            }
            
            initializeOrb() {
                // Make orb draggable for manual navigation
                this.userOrb.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.userOrb.style.cursor = 'grabbing';
                    stateManager.logEvent('Manual orb movement started', 'interaction');
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const rect = document.querySelector('.navigation-canvas').getBoundingClientRect();
                        const x = e.clientX - rect.left - 40;
                        const y = e.clientY - rect.top - 40;
                        
                        const newX = Math.max(0, Math.min(x, rect.width - 80));
                        const newY = Math.max(0, Math.min(y, rect.height - 80));
                        
                        this.userOrb.style.left = newX + 'px';
                        this.userOrb.style.top = newY + 'px';
                        
                        // Update state
                        stateManager.updateState('navigation.orbPosition', {
                            x: (newX / rect.width) * 100,
                            y: (newY / rect.height) * 100
                        });
                        stateManager.updateState('navigation.lastMovement', Date.now());
                        
                        this.checkCenterProximity();
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.userOrb.style.cursor = 'grab';
                        stateManager.logEvent('Manual orb movement ended', 'interaction');
                    }
                });
            }
            
            handleStateChange(state, path, value) {
                // React to state changes from other modules
                if (path.startsWith('biofeedback.')) {
                    this.updateBiofeedbackUI(state.biofeedback);
                } else if (path.startsWith('soulMetrics.')) {
                    this.updateSoulMetricsUI(state.soulMetrics);
                } else if (path === 'navigation.currentTarget') {
                    this.updateTargetVisualization(value);
                } else if (path === 'session.coachingInterventions') {
                    this.triggerCoachingResponse(state);
                }
            }
            
            startBiofeedbackSimulation() {
                // Simulate real-time biofeedback data with state management
                setInterval(() => {
                    const currentBio = stateManager.getState('biofeedback');
                    
                    // Generate new values with trends
                    const hrv = this.generateAdaptiveBiometric('hrv', currentBio.hrv);
                    const breath = this.generateAdaptiveBiometric('breath', currentBio.breath);
                    const coherence = this.generateAdaptiveBiometric('coherence', currentBio.coherence);
                    const focus = this.generateAdaptiveBiometric('focus', currentBio.focus);
                    
                    // Update state
                    stateManager.updateState('biofeedback.hrv', hrv);
                    stateManager.updateState('biofeedback.breath', breath);
                    stateManager.updateState('biofeedback.coherence', coherence);
                    stateManager.updateState('biofeedback.focus', focus);
                    
                    // Update trends
                    this.updateTrends(hrv, breath, coherence, focus);
                    
                    // Calculate soul metrics
                    this.updateSoulMetricsFromBio(hrv, breath, coherence, focus);
                    
                    // Intelligent biofeedback navigation
                    this.intelligentNavigation(coherence, focus);
                }, 1000);
            }
            
            generateAdaptiveBiometric(type, currentValue) {
                const patterns = stateManager.getState('userPatterns');
                const optimal = patterns.learningProfile.optimalMetrics;
                
                // If we have learned optimal values, trend towards them
                if (optimal && optimal[type]) {
                    const target = optimal[type];
                    const drift = (target - currentValue) * 0.1;
                    const noise = (Math.random() - 0.5) * 15;
                    return Math.max(20, Math.min(95, currentValue + drift + noise));
                }
                
                // Default random variation
                const variation = (Math.random() - 0.5) * 20;
                return Math.max(20, Math.min(95, currentValue + variation));
            }
            
            updateTrends(hrv, breath, coherence, focus) {
                const trends = stateManager.getState('biofeedback.trends');
                
                trends.hrv.push(hrv);
                trends.breath.push(breath);
                trends.coherence.push(coherence);
                trends.focus.push(focus);
                
                // Keep only last 20 values
                Object.keys(trends).forEach(key => {
                    if (trends[key].length > 20) {
                        trends[key].shift();
                    }
                });
                
                stateManager.updateState('biofeedback.trends', trends);
            }
            
            generateBiometricValue(type) {
                // Simulate realistic biometric variations
                const base = {
                    hrv: 65,
                    breath: 72,
                    coherence: 58,
                    focus: 80
                };
                
                return base[type] + (Math.random() - 0.5) * 20;
            }
            
            updateBiofeedbackUI(hrv, breath, coherence, focus) {
                document.getElementById('hrvBar').style.width = hrv + '%';
                document.getElementById('hrvValue').textContent = Math.round(hrv) + '%';
                
                document.getElementById('breathBar').style.width = breath + '%';
                document.getElementById('breathValue').textContent = Math.round(breath) + '%';
                
                document.getElementById('coherenceBar').style.width = coherence + '%';
                document.getElementById('coherenceValue').textContent = Math.round(coherence) + '%';
                
                document.getElementById('focusBar').style.width = focus + '%';
                document.getElementById('focusValue').textContent = Math.round(focus) + '%';
            }
            
            updateSoulMetrics(hrv, breath, coherence, focus) {
                const soulCoherence = Math.round((coherence + hrv) / 2);
                const soulVitality = Math.round((breath + focus) / 2);
                const soulEthics = Math.round((coherence + 85) / 2); // Enhanced by mindfulness
                const soulNarrative = Math.round((focus + coherence + hrv) / 3);
                
                document.getElementById('soulCoherence').textContent = soulCoherence + '%';
                document.getElementById('soulVitality').textContent = soulVitality + '%';
                document.getElementById('soulEthics').textContent = soulEthics + '%';
                document.getElementById('soulNarrative').textContent = soulNarrative + '%';
                
                const avgConsciousness = Math.round((soulCoherence + soulVitality + soulEthics + soulNarrative) / 4);
                document.getElementById('consciousnessLevel').textContent = 
                    avgConsciousness > 85 ? 'Transcendent' :
                    avgConsciousness > 70 ? 'Focused' :
                    avgConsciousness > 55 ? 'Developing' : 'Calm';
            }
            
            biofeedbackNavigation(coherence, focus) {
                // Auto-move orb based on biofeedback when coherence and focus are high
                if (coherence > 70 && focus > 75 && !this.isDragging) {
                    const targetCenter = document.querySelector(`[data-center="${this.currentTarget}"]`);
                    if (targetCenter) {
                        const orbRect = this.userOrb.getBoundingClientRect();
                        const targetRect = targetCenter.getBoundingClientRect();
                        
                        const deltaX = (targetRect.left - orbRect.left) * 0.02;
                        const deltaY = (targetRect.top - orbRect.top) * 0.02;
                        
                        const currentLeft = parseInt(this.userOrb.style.left) || 0;
                        const currentTop = parseInt(this.userOrb.style.top) || 0;
                        
                        this.userOrb.style.left = (currentLeft + deltaX) + 'px';
                        this.userOrb.style.top = (currentTop + deltaY) + 'px';
                    }
                }
                
                this.checkCenterProximity();
            }
            
            checkCenterProximity() {
                const orbRect = this.userOrb.getBoundingClientRect();
                const targetCenter = document.querySelector(`[data-center="${this.currentTarget}"]`);
                
                if (targetCenter) {
                    const targetRect = targetCenter.getBoundingClientRect();
                    const distance = Math.sqrt(
                        Math.pow(orbRect.left - targetRect.left, 2) + 
                        Math.pow(orbRect.top - targetRect.top, 2)
                    );
                    
                    this.targetDistance = distance;
                    
                    // Unlock center when close enough
                    if (distance < 100) {
                        this.unlockCenter(this.currentTarget);
                    }
                }
            }
            
            unlockCenter(centerName) {
                const center = document.querySelector(`[data-center="${centerName}"]`);
                if (center && !center.classList.contains('unlocked')) {
                    center.classList.add('unlocked');
                    center.classList.remove('target');
                    
                    this.addProgressItem(`🎯 UNLOCKED: ${centerName.toUpperCase()} center!`);
                    
                    // Move to next center
                    setTimeout(() => {
                        this.setNextTarget();
                    }, 2000);
                }
            }
            
            setNextTarget() {
                const centers = ['presence', 'quality', 'forgiveness', 'awareness', 'compassion'];
                const currentIndex = centers.indexOf(this.currentTarget);
                const nextIndex = (currentIndex + 1) % centers.length;
                
                this.currentTarget = centers[nextIndex];
                
                // Update visual target
                document.querySelectorAll('.center-node').forEach(node => {
                    node.classList.remove('target');
                });
                
                const nextCenter = document.querySelector(`[data-center="${this.currentTarget}"]`);
                if (nextCenter && !nextCenter.classList.contains('unlocked')) {
                    nextCenter.classList.add('target');
                }
            }
            
            startIntelligentCoaching() {
                // Intelligent coaching που μαθαίνει από τον χρήστη
                setInterval(() => {
                    this.analyzeAndCoach();
                }, 3000);
            }
            
            analyzeAndCoach() {
                const state = stateManager.getState();
                const bio = state.biofeedback;
                const nav = state.navigation;
                const patterns = state.userPatterns;
                
                let message = "";
                let coachingType = "neutral";
                
                // Adaptive coaching based on user patterns
                if (nav.stuckCounter > 3) {
                    message = this.generateStuckCoaching(patterns);
                    coachingType = "intervention";
                } else if (bio.coherence > 75 && bio.focus > 80) {
                    message = this.generateSuccessCoaching(patterns);
                    coachingType = "encouragement";
                } else if (this.detectBiometricImbalance(bio)) {
                    message = this.generateBalanceCoaching(bio, patterns);
                    coachingType = "guidance";
                } else {
                    message = this.generateContextualCoaching(state);
                    coachingType = "contextual";
                }
                
                // Update coaching message
                document.getElementById('coachingMessage').textContent = message;
                
                // Log coaching intervention
                stateManager.logEvent(`Coaching: ${coachingType} - ${message}`, 'coaching');
                
                // Track user response to coaching
                this.trackCoachingResponse(coachingType, message);
            }
            
            generateStuckCoaching(patterns) {
                const learningProfile = patterns.learningProfile;
                
                if (learningProfile.respondsTo.includes('breathing')) {
                    return "Take 3 deep breaths. Your patterns show breathing exercises help you most.";
                } else if (learningProfile.respondsTo.includes('visual')) {
                    return "Focus on the glowing connection line. Let it guide your attention.";
                } else if (patterns.stuckPoints.length > 2) {
                    return "I notice this is a challenging area for you. Try a different approach - use manual navigation.";
                } else {
                    return "Sometimes we need to pause. Try releasing control and let your biofeedback guide you.";
                }
            }
            
            generateSuccessCoaching(patterns) {
                const successTriggers = patterns.successTriggers;
                
                if (successTriggers.length > 0) {
                    const lastSuccess = successTriggers[successTriggers.length - 1];
                    return `Excellent! Your ${lastSuccess.context} pattern is working perfectly. Keep this rhythm.`;
                } else {
                    return "Beautiful flow state! Your coherence and focus are perfectly aligned.";
                }
            }
            
            generateBalanceCoaching(bio, patterns) {
                if (bio.hrv < 40) {
                    return "Your heart rate variability needs attention. Try slowing your breath rhythm.";
                } else if (bio.coherence < 30) {
                    return "Let's sync your heart and breath. Breathe in for 4, hold for 4, out for 4.";
                } else if (bio.focus < 50) {
                    return "Your attention is scattered. Gently return focus to the target center.";
                } else {
                    return "Your biometrics show stress. Take a moment to center yourself.";
                }
            }
            
            generateContextualCoaching(state) {
                const target = state.navigation.currentTarget;
                const progress = state.session.totalProgress;
                
                const contextMessages = {
                    presence: "For PRESENCE, imagine you're here, now, fully alive in this moment.",
                    quality: "QUALITY emerges when you do fewer things with deeper attention.",
                    forgiveness: "FORGIVENESS is releasing what no longer serves your growth.",
                    awareness: "AWARENESS is the light that illuminates your inner landscape.",
                    compassion: "COMPASSION starts with being kind to yourself, then extends outward."
                };
                
                if (progress < 20) {
                    return `Starting your journey with ${target.toUpperCase()}. ${contextMessages[target]}`;
                } else if (progress > 80) {
                    return "You're near completion! Feel how each center has transformed your inner state.";
                } else {
                    return contextMessages[target] || "Trust your biofeedback to guide you forward.";
                }
            }
            
            trackCoachingResponse(type, message) {
                // Track how user responds to different coaching approaches
                const response = {
                    timestamp: Date.now(),
                    type,
                    message,
                    biostateBefore: { ...stateManager.getState('biofeedback') },
                    navStateBefore: { ...stateManager.getState('navigation') }
                };
                
                // Check response after 5 seconds
                setTimeout(() => {
                    response.biostateAfter = { ...stateManager.getState('biofeedback') };
                    response.navStateAfter = { ...stateManager.getState('navigation') };
                    response.effectiveness = this.calculateCoachingEffectiveness(response);
                    
                    const responseHistory = stateManager.getState('userPatterns.responseToCoaching');
                    responseHistory.push(response);
                    stateManager.updateState('userPatterns.responseToCoaching', responseHistory);
                }, 5000);
            }
            
            calculateCoachingEffectiveness(response) {
                const before = response.biostateBefore;
                const after = response.biostateAfter;
                
                const coherenceImprovement = after.coherence - before.coherence;
                const focusImprovement = after.focus - before.focus;
                const movement = response.navStateAfter.lastMovement - response.navStateBefore.lastMovement;
                
                return {
                    biofeedbackImprovement: (coherenceImprovement + focusImprovement) / 2,
                    movementInduced: movement > 0,
                    overallEffectiveness: coherenceImprovement > 5 ? 'high' : 
                                        coherenceImprovement > 0 ? 'medium' : 'low'
                };
            }
            
            detectBiometricImbalance(bio) {
                return bio.hrv < 40 || bio.coherence < 30 || bio.focus < 50 || 
                       Math.abs(bio.hrv - bio.coherence) > 30;
            }
            
            updateSoulMetricsFromBio(hrv, breath, coherence, focus) {
                const soulCoherence = Math.round((coherence + hrv) / 2);
                const soulVitality = Math.round((breath + focus) / 2);
                const soulEthics = Math.round((coherence + 85) / 2);
                const soulNarrative = Math.round((focus + coherence + hrv) / 3);
                
                stateManager.updateState('soulMetrics.coherence', soulCoherence);
                stateManager.updateState('soulMetrics.vitality', soulVitality);
                stateManager.updateState('soulMetrics.ethics', soulEthics);
                stateManager.updateState('soulMetrics.narrative', soulNarrative);
                
                const avgConsciousness = Math.round((soulCoherence + soulVitality + soulEthics + soulNarrative) / 4);
                const level = avgConsciousness > 85 ? 'Transcendent' :
                             avgConsciousness > 70 ? 'Focused' :
                             avgConsciousness > 55 ? 'Developing' : 'Calm';
                             
                stateManager.updateState('soulMetrics.consciousnessLevel', level);
            }
            
            updateBiofeedbackUI(bio) {
                document.getElementById('hrvBar').style.width = bio.hrv + '%';
                document.getElementById('hrvValue').textContent = Math.round(bio.hrv) + '%';
                
                document.getElementById('breathBar').style.width = bio.breath + '%';
                document.getElementById('breathValue').textContent = Math.round(bio.breath) + '%';
                
                document.getElementById('coherenceBar').style.width = bio.coherence + '%';
                document.getElementById('coherenceValue').textContent = Math.round(bio.coherence) + '%';
                
                document.getElementById('focusBar').style.width = bio.focus + '%';
                document.getElementById('focusValue').textContent = Math.round(bio.focus) + '%';
            }
            
            updateSoulMetricsUI(soul) {
                document.getElementById('soulCoherence').textContent = soul.coherence + '%';
                document.getElementById('soulVitality').textContent = soul.vitality + '%';
                document.getElementById('soulEthics').textContent = soul.ethics + '%';
                document.getElementById('soulNarrative').textContent = soul.narrative + '%';
                document.getElementById('consciousnessLevel').textContent = soul.consciousnessLevel;
            }
            
            intelligentNavigation(coherence, focus) {
                // Auto-move orb based on biofeedback when coherence and focus are high
                if (coherence > 70 && focus > 75 && !this.isDragging) {
                    const state = stateManager.getState();
                    const targetCenter = document.querySelector(`[data-center="${state.navigation.currentTarget}"]`);
                    if (targetCenter) {
                        const orbRect = this.userOrb.getBoundingClientRect();
                        const targetRect = targetCenter.getBoundingClientRect();
                        
                        const deltaX = (targetRect.left - orbRect.left) * 0.02;
                        const deltaY = (targetRect.top - orbRect.top) * 0.02;
                        
                        const currentLeft = parseInt(this.userOrb.style.left) || 0;
                        const currentTop = parseInt(this.userOrb.style.top) || 0;
                        
                        this.userOrb.style.left = (currentLeft + deltaX) + 'px';
                        this.userOrb.style.top = (currentTop + deltaY) + 'px';
                        
                        stateManager.logEvent('Biofeedback navigation active', 'navigation');
                        stateManager.updateState('navigation.lastMovement', Date.now());
                    }
                }
                
                this.checkCenterProximity();
            }
            
            checkCenterProximity() {
                const state = stateManager.getState();
                const orbRect = this.userOrb.getBoundingClientRect();
                const targetCenter = document.querySelector(`[data-center="${state.navigation.currentTarget}"]`);
                
                if (targetCenter) {
                    const targetRect = targetCenter.getBoundingClientRect();
                    const distance = Math.sqrt(
                        Math.pow(orbRect.left - targetRect.left, 2) + 
                        Math.pow(orbRect.top - targetRect.top, 2)
                    );
                    
                    stateManager.updateState('navigation.targetDistance', distance);
                    
                    // Unlock center when close enough
                    if (distance < 100) {
                        this.unlockCenter(state.navigation.currentTarget);
                    }
                }
            }
            
            unlockCenter(centerName) {
                const center = document.querySelector(`[data-center="${centerName}"]`);
                const state = stateManager.getState();
                
                if (center && !state.navigation.unlockedCenters.includes(centerName)) {
                    center.classList.add('unlocked');
                    center.classList.remove('target');
                    
                    const newUnlocked = [...state.navigation.unlockedCenters, centerName];
                    stateManager.updateState('navigation.unlockedCenters', newUnlocked);
                    
                    this.addProgressItem(`🎯 UNLOCKED: ${centerName.toUpperCase()} center!`);
                    
                    // Move to next center
                    setTimeout(() => {
                        this.setNextTarget();
                    }, 2000);
                }
            }
            
            setNextTarget() {
                const centers = ['presence', 'quality', 'forgiveness', 'awareness', 'compassion'];
                const state = stateManager.getState();
                const currentIndex = centers.indexOf(state.navigation.currentTarget);
                const nextIndex = (currentIndex + 1) % centers.length;
                
                stateManager.updateState('navigation.currentTarget', centers[nextIndex]);
            }
            
            updateTargetVisualization(newTarget) {
                // Update visual target
                document.querySelectorAll('.center-node').forEach(node => {
                    node.classList.remove('target');
                });
                
                const nextCenter = document.querySelector(`[data-center="${newTarget}"]`);
                const state = stateManager.getState();
                
                if (nextCenter && !state.navigation.unlockedCenters.includes(newTarget)) {
                    nextCenter.classList.add('target');
                }
            }
            
            triggerCoachingResponse(state) {
                // Visual feedback for coaching interventions
                const coachingPanel = document.querySelector('.coaching-panel');
                coachingPanel.style.borderColor = '#00b894';
                coachingPanel.style.boxShadow = '0 0 15px rgba(0, 184, 148, 0.3)';
                
                setTimeout(() => {
                    coachingPanel.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                    coachingPanel.style.boxShadow = 'none';
                }, 2000);
            }
            
            addProgressItem(message) {
                const progressPanel = document.querySelector('.progress-panel');
                const timestamp = new Date().toLocaleTimeString();
                const item = document.createElement('div');
                item.className = 'progress-item';
                item.textContent = `${timestamp} - ${message}`;
                
                progressPanel.insertBefore(item, progressPanel.children[1]);
                
                // Keep only last 10 items
                const items = progressPanel.querySelectorAll('.progress-item');
                if (items.length > 10) {
                    items[items.length - 1].remove();
                }
            }
            
            drawConnectionLines() {
                // Draw connecting lines between orb and target
                setInterval(() => {
                    const orbRect = this.userOrb.getBoundingClientRect();
                    const targetCenter = document.querySelector(`[data-center="${this.currentTarget}"]`);
                    
                    if (targetCenter) {
                        const targetRect = targetCenter.getBoundingClientRect();
                        const container = document.getElementById('connectionLines');
                        container.innerHTML = '';
                        
                        const line = document.createElement('div');
                        line.className = 'connection-line';
                        
                        const deltaX = targetRect.left - orbRect.left;
                        const deltaY = targetRect.top - orbRect.top;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                        
                        line.style.width = distance + 'px';
                        line.style.left = (orbRect.left - document.querySelector('.navigation-canvas').getBoundingClientRect().left) + 'px';
                        line.style.top = (orbRect.top - document.querySelector('.navigation-canvas').getBoundingClientRect().top + 40) + 'px';
                        line.style.transform = `rotate(${angle}deg)`;
                        
                        container.appendChild(line);
                    }
                }, 100);
            }
        }
        
        // Initialize the 2D Book Centers system
        document.addEventListener('DOMContentLoaded', () => {
            new BookCenters2D();
        });
    </script>
</body>
</html>