<!DOCTYPE html>
<html lang="el" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>{{ book_data.title }} - Integrated Experience [v2.1]</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(circle at center, #0a0a0f 0%, #000000 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui;
            height: 100vh;
            overflow: hidden;
            color: white;
            position: relative;
        }
        
        .cosmos-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            perspective: 1000px;
        }
        
        .center-space {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            transition: all 0.8s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 300;
            text-align: center;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        .center-space.active {
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
            transform: scale(1.2);
        }
        
        .center-space.target {
            animation: targetPulse 2s ease-in-out infinite;
        }
        
        .center-space.locked {
            animation: lockedGlow 1s ease-in-out infinite;
        }
        
        /* User Current State */
        .user-state {
            position: absolute;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, rgba(0,255,255,0.8), rgba(0,255,255,0.3));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 0 0 10px cyan;
            box-shadow: 0 0 20px rgba(0,255,255,0.5);
            transition: transform 0.1s ease;
            z-index: 1000;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.2) 100%);
            border: 3px solid rgba(255, 255, 255, 0.9);
            top: 45%;
            left: 10%;
            transition: all 1.5s ease-in-out;
            animation: userPulse 3s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            z-index: 100;
            cursor: pointer;
        }
        
        /* Spatial Demo Mode Styles */
        .spatial-demo-controls {
            position: fixed;
            top: 20px;
            right: 320px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }
        
        .spatial-demo-btn {
            padding: 8px 12px;
            background: linear-gradient(135deg, #ff6b35, #ff8c42);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
        }
        
        .spatial-demo-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(255, 107, 53, 0.5);
            background: linear-gradient(135deg, #ff5722, #ff7043);
        }
        
        .spatial-demo-timer {
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            color: #00ff88;
            font-family: monospace;
            font-size: 14px;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }
        
        /* PRESENCE zone CSS removed - now using two circles only (AWARENESS + COMPASSION) */
        
        /* FRACTAL MANIFOLD VISUALIZATION */
        .fractal-manifold-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s ease;
            z-index: 1;
        }
        
        .fractal-manifold-overlay.active {
            opacity: 0.3;
        }
        
        .hrv-field-contour {
            position: absolute;
            border-radius: 50%;
            border: 1px solid rgba(100, 200, 255, 0.3);
            animation: contourPulse 4s ease-in-out infinite;
        }
        
        .hrv-field-contour:nth-child(1) {
            width: 200px;
            height: 200px;
            top: 20%;
            left: 30%;
            animation-delay: 0s;
        }
        
        .hrv-field-contour:nth-child(2) {
            width: 150px;
            height: 150px;
            top: 50%;
            left: 60%;
            animation-delay: 1s;
        }
        
        .hrv-field-contour:nth-child(3) {
            width: 100px;
            height: 100px;
            top: 70%;
            left: 20%;
            animation-delay: 2s;
        }
        
        @keyframes contourPulse {
            0%, 100% {
                border-color: rgba(100, 200, 255, 0.2);
                transform: scale(1);
            }
            50% {
                border-color: rgba(100, 255, 200, 0.6);
                transform: scale(1.2);
            }
        }
        
        /* FRACTAL PATTERN OVERLAY */
        .fractal-pattern {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            animation: fractalSpin 8s linear infinite;
        }
        
        .fractal-pattern.level-1 {
            top: 25%;
            left: 45%;
            animation-duration: 8s;
        }
        
        .fractal-pattern.level-2 {
            top: 65%;
            left: 35%;
            animation-duration: 12s;
            border-color: rgba(100, 255, 100, 0.3);
        }
        
        .fractal-pattern.level-3 {
            top: 45%;
            left: 70%;
            animation-duration: 16s;
            border-color: rgba(255, 100, 255, 0.3);
        }
        
        @keyframes fractalSpin {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(0.9); }
            75% { transform: rotate(270deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }
        
        /* ACTIVE MEMORY VISUALIZATION */
        .memory-stream-visual {
            position: absolute;
            top: 10%;
            right: 10%;
            width: 4px;
            height: 80%;
            background: linear-gradient(180deg, 
                rgba(0, 255, 200, 0.8) 0%,
                rgba(100, 200, 255, 0.6) 30%,
                rgba(255, 100, 200, 0.4) 60%,
                rgba(255, 255, 100, 0.2) 100%);
            border-radius: 2px;
            opacity: 0;
            animation: memoryFlow 3s ease-in-out infinite;
        }
        
        .memory-stream-visual.active {
            opacity: 1;
        }
        
        @keyframes memoryFlow {
            0%, 100% {
                background: linear-gradient(180deg, 
                    rgba(0, 255, 200, 0.8) 0%,
                    rgba(100, 200, 255, 0.6) 30%,
                    rgba(255, 100, 200, 0.4) 60%,
                    rgba(255, 255, 100, 0.2) 100%);
            }
            50% {
                background: linear-gradient(180deg, 
                    rgba(255, 255, 100, 0.8) 0%,
                    rgba(255, 100, 200, 0.6) 30%,
                    rgba(100, 200, 255, 0.4) 60%,
                    rgba(0, 255, 200, 0.2) 100%);
            }
        }
        
        .user-state.moving {
            transform: translateX(100px) translateY(-50px);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.6);
        }
        
        /* Connection Lines */
        .connection-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0.8) 100%);
            transform-origin: left center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .connection-line.active {
            opacity: 1;
            animation: connectionFlow 2s ease-in-out infinite;
        }
        
        /* Status Display */
        .status-display {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }
        
        .book-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 5px;
            opacity: 0.9;
        }
        
        .current-chapter {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .alignment-score {
            font-size: 24px;
            font-weight: 600;
            color: #3b82f6;
        }
        
        /* ALL SYSTEMS INTEGRATED PANEL - ALWAYS VISIBLE AND ACTIVE */
        .integrated-systems-panel {
            position: fixed !important;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(34, 197, 94, 0.5);
            backdrop-filter: blur(15px);
            min-width: 320px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
            box-shadow: 0 12px 40px rgba(34, 197, 94, 0.3), 0 0 60px rgba(0, 0, 0, 0.8);
            animation: panelActivePulse 4s ease-in-out infinite;
        }
        
        @keyframes panelActivePulse {
            0%, 100% { 
                border-color: rgba(34, 197, 94, 0.5);
                box-shadow: 0 12px 40px rgba(34, 197, 94, 0.3), 0 0 60px rgba(0, 0, 0, 0.8);
            }
            50% { 
                border-color: rgba(34, 197, 94, 0.8);
                box-shadow: 0 12px 40px rgba(34, 197, 94, 0.5), 0 0 80px rgba(34, 197, 94, 0.2);
            }
        }
        
        .system-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .system-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .system-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .system-status {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #22c55e;
            margin-right: 6px;
            animation: statusPulse 2s ease-in-out infinite;
        }
        
        .metric-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 11px;
        }
        
        .metric-label {
            opacity: 0.8;
        }
        
        .metric-value {
            color: #22c55e;
            font-weight: 600;
        }
        
        .personality-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 2px;
            overflow: hidden;
        }
        
        .personality-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #22c55e);
            transition: width 0.8s ease;
        }
        
        /* Memory Stream */
        .memory-stream {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 320px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            max-height: 150px;
            overflow-y: auto;
        }
        
        .memory-item {
            font-size: 11px;
            padding: 4px 0;
            opacity: 0.8;
            border-left: 2px solid #3b82f6;
            padding-left: 8px;
            margin-bottom: 4px;
        }
        
        .memory-timestamp {
            color: #6b7280;
            font-size: 10px;
        }
        
        /* Navigation */
        .nav-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            text-decoration: none;
            font-size: 11px;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            text-decoration: none;
        }
        
        /* Animations */
        @keyframes targetPulse {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 40px rgba(255, 255, 255, 0.6);
                transform: scale(1.1);
            }
        }
        
        @keyframes lockedGlow {
            0%, 100% { 
                box-shadow: 0 0 30px rgba(34, 197, 94, 0.6);
            }
            50% { 
                box-shadow: 0 0 50px rgba(34, 197, 94, 0.9);
            }
        }
        
        @keyframes userPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        /* PRESENCE Agent Message Animations */
        @keyframes presenceMessageFadeIn {
            0% { 
                opacity: 0; 
                transform: translateY(20px) scale(0.9);
            }
            100% { 
                opacity: 1; 
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes presenceMessageFadeOut {
            0% { 
                opacity: 1; 
                transform: translateY(0) scale(1);
            }
            100% { 
                opacity: 0; 
                transform: translateY(-20px) scale(0.9);
            }
        }
        
        .presence-agent-message {
            transition: all 0.3s ease-in-out;
        }
        
        .presence-agent-message .agent-message-content {
            position: relative;
            overflow: hidden;
        }
        
        .presence-agent-message .agent-message-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shimmer 3s ease-in-out infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }
        
        /* SPATIAL INTELLIGENCE VISUAL FEEDBACK ANIMATIONS */
        @keyframes urgentPulse {
            0%, 100% { 
                transform: scale(1.3);
                box-shadow: 0 0 50px rgba(255, 69, 0, 1), 0 0 100px rgba(255, 215, 0, 0.8);
            }
            50% { 
                transform: scale(1.5);
                box-shadow: 0 0 70px rgba(255, 69, 0, 1), 0 0 120px rgba(255, 215, 0, 1);
            }
        }
        
        @keyframes gentlePulse {
            0%, 100% { 
                transform: scale(1.0);
                box-shadow: 0 0 20px rgba(79, 172, 254, 0.6);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 0 30px rgba(79, 172, 254, 0.8);
            }
        }
        
        @keyframes bridgeFlow {
            0% {
                background: linear-gradient(90deg, 
                    rgba(255, 69, 0, 0.9) 0%, 
                    rgba(255, 215, 0, 0.7) 10%, 
                    rgba(255, 69, 0, 0.5) 20%,
                    transparent 30%);
            }
            50% {
                background: linear-gradient(90deg, 
                    transparent 0%,
                    rgba(255, 69, 0, 0.5) 30%, 
                    rgba(255, 215, 0, 0.7) 50%, 
                    rgba(255, 69, 0, 0.9) 60%,
                    transparent 70%);
            }
            100% {
                background: linear-gradient(90deg, 
                    transparent 70%,
                    rgba(255, 69, 0, 0.5) 80%, 
                    rgba(255, 215, 0, 0.7) 90%, 
                    rgba(255, 69, 0, 0.9) 100%);
            }
        }
        
        @keyframes personalityPulse {
            0% { transform: scaleY(1); box-shadow: none; }
            50% { transform: scaleY(1.1); box-shadow: 0 0 15px currentColor; }
            100% { transform: scaleY(1); box-shadow: 0 0 8px currentColor; }
        }
        
        @keyframes soulPulse {
            0%, 100% { 
                transform: scale(1) rotate(0deg); 
                filter: brightness(1); 
            }
            50% { 
                transform: scale(1.05) rotate(2deg); 
                filter: brightness(1.2); 
            }
        }
        
        @keyframes soulTrailFade {
            0% { opacity: 0.8; transform: scale(1) translate(0, 0); }
            50% { opacity: 0.4; transform: scale(1.2) translate(-5px, -10px); }
            100% { opacity: 0; transform: scale(0.8) translate(-10px, -20px); }
        }
        
        @keyframes memoryStreamPulse {
            0%, 100% { 
                background: rgba(0, 0, 0, 0.7);
                border-color: rgba(255, 255, 255, 0.2);
            }
            50% { 
                background: rgba(15, 23, 42, 0.9);
                border-color: rgba(79, 172, 254, 0.5);
            }
        }
        
        /* Agent recall behaviors */
        @keyframes agentSeekingMovement {
            0% { transform: translateX(0) translateY(0) scale(1); }
            25% { transform: translateX(-5px) translateY(-3px) scale(1.1); }
            50% { transform: translateX(0) translateY(-5px) scale(1.2); }
            75% { transform: translateX(5px) translateY(-3px) scale(1.1); }
            100% { transform: translateX(0) translateY(0) scale(1); }
        }
        
        @keyframes agentIdleDrift {
            0% { transform: translateX(0) translateY(0) rotate(0deg); }
            25% { transform: translateX(2px) translateY(-1px) rotate(1deg); }
            50% { transform: translateX(0) translateY(-2px) rotate(0deg); }
            75% { transform: translateX(-2px) translateY(-1px) rotate(-1deg); }
            100% { transform: translateX(0) translateY(0) rotate(0deg); }
        }
        
        /* Debug Panel Styles */
        .debug-panel {
            position: fixed;
            top: 50px;
            right: 20px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #00ff88;
            width: 320px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 9999;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(10px);
            transform: translateX(340px);
            opacity: 0;
            transition: all 0.4s ease;
        }
        
        .debug-panel.visible {
            transform: translateX(0);
            opacity: 1;
        }
        
        .debug-header {
            color: #ffffff;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #00ff88;
        }
        
        .debug-section {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }
        
        .debug-label {
            color: #ffaa00;
            display: inline-block;
            min-width: 100px;
        }
        
        .debug-value {
            color: #00ffff;
        }
        
        .debug-line {
            margin: 5px 0;
        }
        
        @keyframes connectionFlow {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }
        
        @keyframes statusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        /* Chat Integration */
        .chat-integration {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 260px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(15px);
            display: none;
        }
        
        .chat-integration.active {
            display: block;
            animation: slideIn 0.5s ease;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-50%) translateX(20px); }
            to { opacity: 1; transform: translateY(-50%) translateX(0); }
        }
        
        @keyframes attractPulse {
            0%, 100% { 
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.6);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 50px rgba(255, 255, 255, 0.9);
                transform: scale(1.1);
            }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.05); opacity: 1; }
        }
        
        @keyframes centerEnlightenment {
            0% { transform: scale(1); box-shadow: 0 0 10px rgba(79, 172, 254, 0.5); }
            50% { transform: scale(1.3); box-shadow: 0 0 50px rgba(79, 172, 254, 1), 0 0 100px rgba(34, 197, 94, 0.8); }
            100% { transform: scale(1.2); box-shadow: 0 0 50px rgba(79, 172, 254, 1), 0 0 100px rgba(34, 197, 94, 0.6); }
        }
        
        @keyframes slideInGlow {
            0% { 
                opacity: 0; 
                transform: translateX(-50%) translateY(-20px); 
                box-shadow: 0 0 0 rgba(79, 172, 254, 0); 
            }
            100% { 
                opacity: 1; 
                transform: translateX(-50%) translateY(0); 
                box-shadow: 0 12px 40px rgba(0,0,0,0.4), 0 0 30px rgba(79, 172, 254, 0.3); 
            }
        } 
                box-shadow: 0 0 60px rgba(255, 255, 255, 0.9);
                transform: scale(1.15);
            }
        }
        
        @keyframes alternativePulse {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(34, 197, 94, 0.4);
            }
            50% { 
                box-shadow: 0 0 40px rgba(34, 197, 94, 0.8);
            }
        }
        
        @keyframes coachFadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        @keyframes coachFadeOut {
            from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            to { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        /* SPATIAL INTELLIGENCE ANIMATIONS */
        @keyframes targetPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            }
            50% { 
                transform: scale(1.2);
                box-shadow: 0 0 40px rgba(255, 215, 0, 1);
            }
        }
        
        @keyframes connectionFlow {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        @keyframes presenceMessageFadeIn {
            from { opacity: 0; transform: translateY(20px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes presenceMessageFadeOut {
            from { opacity: 1; transform: translateY(0) scale(1); }
            to { opacity: 0; transform: translateY(-20px) scale(0.9); }
        }
        
        /* 🌟 SOUL METRICS ANIMATIONS - Advanced consciousness mapping */
        @keyframes soulPulse {
            0%, 100% { 
                transform: scale(var(--base-scale, 1)) rotate(0deg); 
                filter: brightness(1);
            }
            50% { 
                transform: scale(calc(var(--base-scale, 1) * 1.08)) rotate(3deg); 
                filter: brightness(1.2);
            }
        }
        
        @keyframes soulTrailFade {
            0% {
                opacity: 0.7;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.2);
            }
        }
        
        /* Soul Vitality states */
        [data-soul-vitality="animated"] {
            transition: all 0.3s ease-in-out;
        }
        
        [data-soul-vitality="static"] {
            animation: none !important;
            transition: all 0.5s ease-out;
        }
        
        /* Soul narrative trail styling */
        .soul-narrative-trail {
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 8px currentColor;
        }
    </style>
    
<style>
  /* kill any metric help / tooltip */
  #metricHelp, .metric-tooltip, .soul-tip, .metric-help-popover { display:none !important; visibility:hidden !important; opacity:0 !important; pointer-events:none !important; }
</style>
</head>
<body>
    <div class="cosmos-container" id="cosmosContainer">
        <!-- Status Display -->
        <div class="status-display">
            <div class="book-title">{{ book_data.title }}</div>
            <div class="current-chapter" id="currentChapter">Integrated Experience Active</div>
            <div class="alignment-score" id="alignmentScore">0%</div>
        </div>
        
        <!-- Spatial Demo Controls -->
        <div class="spatial-demo-controls">
            <button class="spatial-demo-btn" id="spatialDemoBtn" onclick="toggleSpatialDemo()">
                🚀 5min Spatial Demo
            </button>
            <div class="spatial-demo-timer" id="spatialTimer" style="display: none;">5:00</div>
        </div>
        
        <!-- Note: PRESENCE zone removed per user request - now using two circles only -->
        
        <!-- FRACTAL MANIFOLD VISUALIZATION OVERLAY -->
        <div class="fractal-manifold-overlay" id="fractalManifoldOverlay">
            <!-- HRV Field Contours (like manifold_visualization.py) -->
            <div class="hrv-field-contour"></div>
            <div class="hrv-field-contour"></div>
            <div class="hrv-field-contour"></div>
            
            <!-- Fractal Patterns (L2 regularized smooth transitions) -->
            <div class="fractal-pattern level-1"></div>
            <div class="fractal-pattern level-2"></div>
            <div class="fractal-pattern level-3"></div>
            
            <!-- Active Memory Stream Visualization -->
            <div class="memory-stream-visual" id="memoryStreamVisual"></div>
        </div>
        
        <!-- ALL SYSTEMS INTEGRATED PANEL -->
        <div class="integrated-systems-panel">
            <!-- Soul Metrics -->
            <div class="system-section">
                <div class="system-title">
                    <span class="system-status"></span>
                    📊 Soul Metrics
                </div>
                <div class="metric-item">
                    <span class="metric-label">Coherence</span>
                    <span class="metric-value" id="coherenceScore">0%</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="coherenceBar" style="width: 0%; background: linear-gradient(90deg, #3b82f6, #22c55e);"></div>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Vitality</span>
                    <span class="metric-value" id="vitalityScore">0%</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="vitalityBar" style="width: 0%; background: linear-gradient(90deg, #3b82f6, #22c55e);"></div>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Ethics</span>
                    <span class="metric-value" id="ethicsScore">0%</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="ethicsBar" style="width: 0%; background: linear-gradient(90deg, #3b82f6, #22c55e);"></div>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Narrative</span>
                    <span class="metric-value" id="narrativeScore">0%</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="narrativeBar" style="width: 0%; background: linear-gradient(90deg, #3b82f6, #22c55e);"></div>
                </div>
            </div>
            
            <!-- USER PERSONAL EVOLUTION -->
            <div class="system-section" style="background: rgba(34, 197, 94, 0.05); border: 1px solid rgba(34, 197, 94, 0.2);">
                <div class="system-title">
                    <span class="system-status"></span>
                    🧠 Your Evolution (Real-time)
                </div>
                <div class="metric-item">
                    <span class="metric-label">Empathy</span>
                    <span class="metric-value" id="userEmpathyScore">50%</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="userEmpathyBar" style="width: 50%; background: linear-gradient(90deg, #22c55e, #16a34a);"></div>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Creativity</span>
                    <span class="metric-value" id="userCreativityScore">50%</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="userCreativityBar" style="width: 50%; background: linear-gradient(90deg, #22c55e, #16a34a);"></div>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Resilience</span>
                    <span class="metric-value" id="userResilienceScore">50%</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="userResilienceBar" style="width: 50%; background: linear-gradient(90deg, #22c55e, #16a34a);"></div>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Focus</span>
                    <span class="metric-value" id="userFocusScore">50%</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="userFocusBar" style="width: 50%; background: linear-gradient(90deg, #22c55e, #16a34a);"></div>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Curiosity</span>
                    <span class="metric-value" id="userCuriosityScore">50%</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="userCuriosityBar" style="width: 50%; background: linear-gradient(90deg, #22c55e, #16a34a);"></div>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Compassion</span>
                    <span class="metric-value" id="userCompassionScore">50%</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="userCompassionBar" style="width: 50%; background: linear-gradient(90deg, #22c55e, #16a34a);"></div>
                </div>
                <button class="nav-btn" onclick="experience.showEvolutionHistory()" style="margin-top: 8px; font-size: 9px; padding: 4px;">
                    📊 Evolution History
                </button>
                <button class="nav-btn" onclick="experience.toggleSelfReflection()" style="margin-top: 3px; font-size: 9px; padding: 4px;">
                    🪞 Self-Reflection Mode
                </button>
            </div>

            <!-- AI Personality Traits -->
            <div class="system-section">
                <div class="system-title">
                    <span class="system-status"></span>
                    🎭 AI Adaptation (to match you)
                </div>
                <div class="metric-item">
                    <span class="metric-label">Empathy</span>
                    <span class="metric-value" id="empathyTrait">0.50</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="empathyBar" style="width: 50%"></div>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Analytical</span>
                    <span class="metric-value" id="analyticalTrait">0.50</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="analyticalBar" style="width: 50%"></div>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Curiosity</span>
                    <span class="metric-value" id="curiosityTrait">0.50</span>
                </div>
                <div class="personality-bar">
                    <div class="personality-fill" id="curiosityBar" style="width: 50%"></div>
                </div>
            </div>
            
            <!-- HRV Biometrics -->
            <div class="system-section">
                <div class="system-title">
                    <span class="system-status"></span>
                    💓 HRV Biometrics
                </div>
                <div class="metric-item">
                    <span class="metric-label">HRV</span>
                    <span class="metric-value" id="hrvValue">--</span>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Breath</span>
                    <span class="metric-value" id="breathRate">--</span>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Coherence</span>
                    <span class="metric-value" id="hrvCoherence">--</span>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Focus</span>
                    <span class="metric-value" id="focusValue">--</span>
                </div>
            </div>
            
            <!-- Memory System -->
            <div class="system-section">
                <div class="system-title">
                    <span class="system-status"></span>
                    🧠 Active Memory
                </div>
                <div class="metric-item">
                    <span class="metric-label">Context Items</span>
                    <span class="metric-value" id="memoryItems">--</span>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Retention</span>
                    <span class="metric-value" id="memoryRetention">--</span>
                </div>
            </div>
            
            <!-- Anomaly Detection -->
            <div class="system-section">
                <div class="system-title">
                    <span class="system-status"></span>
                    🔮 Pattern Analysis
                </div>
                <div class="metric-item">
                    <span class="metric-label">Behavior</span>
                    <span class="metric-value" id="behaviorStatus">Normal</span>
                </div>
                <div class="metric-item">
                    <span class="metric-label">Insights</span>
                    <span class="metric-value" id="insightCount">0</span>
                </div>
            </div>
        </div>
        
        <!-- User Current State -->
        <div class="user-state" id="userState" style="left: 300px; top: 300px;">
            YOU
        </div>
        
        <!-- Dynamic Book Centers -->
        {% for center in book_data.centers %}
        <div class="center-space" id="{{ center.id }}" 
             style="background: {{ center.get('pattern', {}).get('color', '#4facfe') }}; 
                    border: 2px solid {{ center.get('pattern', {}).get('border_color', '#4facfe') }};
                    top: {{ center.get('position', {}).get('top', '50%') }}; 
                    left: {{ center.get('position', {}).get('left', '50%') }};
                    {{ center.get('css_shape', '') }}">
            {{ center.name }}
        </div>
        {% endfor %}
        
        <!-- Connection Lines -->
        <div class="connection-line" id="connectionLine"></div>
        
        <!-- Memory Stream -->
        <div class="memory-stream">
            <div style="font-size: 12px; font-weight: 600; margin-bottom: 8px;">🧠 Active Memory Stream</div>
            <div id="memoryStreamContent">
                <div class="memory-item">
                    Initializing integrated memory system...
                    <div class="memory-timestamp">{{ session_id }}</div>
                </div>
            </div>
        </div>
        
        <!-- Debug Panel -->
        <div id="debugPanel" class="debug-panel">
            <div class="debug-header">🔍 HRV DEBUG MODE</div>
            
            <div class="debug-section">
                <div class="debug-line">
                    <span class="debug-label">Status:</span>
                    <span class="debug-value" id="debugStatus">Active</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">Window:</span>
                    <span class="debug-value" id="debugWindow">60s</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">Alpha:</span>
                    <span class="debug-value" id="debugAlpha">0.25</span>
                </div>
            </div>
            
            <div class="debug-section">
                <div class="debug-line">
                    <span class="debug-label">RR Count:</span>
                    <span class="debug-value" id="debugRRCount">0</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">RMSSD Raw:</span>
                    <span class="debug-value" id="debugRMSSDRaw">--</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">RMSSD Window:</span>
                    <span class="debug-value" id="debugRMSSDWindow">--</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">RMSSD Smooth:</span>
                    <span class="debug-value" id="debugRMSSDSmooth">--</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">SDNN Window:</span>
                    <span class="debug-value" id="debugSDNNWindow">--</span>
                </div>
            </div>
            
            <div class="debug-section">
                <div class="debug-line">
                    <span class="debug-label">Heart Rate:</span>
                    <span class="debug-value" id="debugHeartRate">75 BPM</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">Last Update:</span>
                    <span class="debug-value" id="debugLastUpdate">--</span>
                </div>
                <div class="debug-line">
                    <span class="debug-label">Device:</span>
                    <span class="debug-value" id="debugDevice">Simulation</span>
                </div>
            </div>
        </div>

        <!-- Navigation -->
        <div class="nav-controls">
            <a href="/upload-book" class="nav-btn">📚 New Book</a>
            <a href="/ultra" class="nav-btn">🧘 Breathing</a>
            <a href="/soul-metrics" class="nav-btn">📊 Metrics</a>
            <button class="nav-btn" onclick="toggleChat()">💬 Chat</button>
            <button class="nav-btn" onclick="experience.triggerCenterLostDemo()" id="testCenterLostBtn">🧪 Test CENTER LOST</button>
            <button class="nav-btn" onclick="toggleDebugPanel()" id="debugToggleBtn">🔍 Debug</button>
        </div>
    </div>

    <script>
        // 🚫 BUILD FLAG: Disable all client simulations (PRODUCTION READY)
        const DISABLE_CLIENT_SIMULATIONS = true;
        
        // 🚀 CACHE BUST v2.1 - Fixed hawkinsLevel error - System operational!
        const bookData = {{ book_data | tojson }};
        const sessionId = "{{ session_id }}";
        const personalityTraits = {{ personality_traits | tojson }};
        
        class IntegratedBookCentersExperience {
            constructor() {
                this.currentTargetIndex = 0;
                this.centers = bookData.centers;
                this.memoryItems = [];
                
                // 🚫 CRITICAL NO-SIGNAL FREEZE CONTROL
                this.hasLiveSignal = false;
                this.signalStatus = "UNKNOWN";
                this.debugOverlay = {};
                this.motionFrozen = false;
                this.wsConnected = false;
                this.lastHRVFrame = null;
                
                // Initialize core objects to prevent undefined errors
                this.youNode = {
                    frozen: false,
                    velocity: { x: 0, y: 0 },
                    acceleration: { x: 0, y: 0 },
                    opacity: 1.0,
                    active: true,
                    hasTrail: true
                };
                
                this.animationState = {
                    frozen: false
                };
                
                this.systemMetrics = {
                    soul: { coherence: 0, vitality: 0, ethics: 0, narrative: 0 },
                    hrv: { hrv: 0, breath: 0, coherence: 0, focus: 0 }, // Όλα μηδέν εκτός από live
                    memory: { items: 0, retention: 0 }, // Και το retention στο 0
                    anomaly: { behavior: 'Normal', insights: 0 }
                };
                
                // 🎯 EMA SMOOTHING for Soul metrics to prevent spike-induced inflation
                this.smoothedSoul = { coherence: 0, vitality: 0, ethics: 0, narrative: 0 };
                this.EMA_ALPHA = 0.1; // 10% new data, 90% smoothed history
                
                // 🧠 EVIDENCE-BASED EVOLUTION CONFIDENCE SYSTEM
                this.evolutionEvidence = {
                    validMinutes: 0,              // Total minutes with live signal + evidence
                    sessionStart: Date.now(),     // When this session started
                    lastEvidenceTime: 0,          // Last time we saw valid evidence
                    confidenceLevel: 0,           // 0-1, based on accumulated evidence
                    minValidMinutes: 10,          // Minimum minutes for full confidence
                    evidenceTracker: {}           // Track evidence per trait
                };
                
                // USER PERSONALITY EVOLUTION TRACKING SYSTEM
                this.userEvolution = {
                    // Current validated personality scores (scientifically tracked)
                    currentPersonality: {
                        empathy: 0.5,
                        creativity: 0.5,
                        resilience: 0.5,
                        focus: 0.5,
                        curiosity: 0.5,
                        compassion: 0.5
                    },
                    
                    // Historical evolution data
                    evolutionHistory: [],
                    
                    // Behavioral markers for score validation
                    behavioralMarkers: {
                        compassionTasks: { completed: 0, avgHRV: 0, stuckCount: 0 },
                        creativeTasks: { timeSpent: 0, flowStates: 0, coherencePeaks: 0 },
                        focusTasks: { sustained: 0, avgFocus: 0, distractions: 0 },
                        empathyTasks: { responses: [], emotionalStability: 0 },
                        resilienceTasks: { recoveryTime: 0, adaptations: 0 }
                    },
                    
                    // Biofeedback correlations
                    biofeedbackCorrelations: {
                        hrvStability: 0,
                        coherenceTrends: [],
                        focusConsistency: 0,
                        stressResponse: 0
                    },
                    
                    // Self-assessment alignment
                    selfAssessment: {
                        lastUpdate: null,
                        validatedScores: {},
                        correlationAccuracy: 0
                    }
                };
                
                // ADVANCED SPATIAL INTELLIGENCE - MULTI-DIMENSIONAL CONSCIOUSNESS MAPPING
                this.spatialIntelligence = {
                    centerLost: false,
                    currentDistance: 0,
                    threshold: 0.7, // Distance threshold for center-loss
                    riskLevel: 'low',
                    stabilityScore: 1.0,
                    trajectoryTrend: 'stable',
                    interventionActive: false,
                    
                    // CONSCIOUSNESS MAPPING SYSTEM - Maps personality traits to spatial coordinates
                    consciousnessMap: {
                        // Spatial Axes Definition - The "Inner Map" of the mind
                        axes: {
                            x: { 
                                left: 'empathy',     // Left side = Feeling, Emotional connection
                                right: 'analytical', // Right side = Thinking, Logical analysis
                                range: 300,          // How far YOU can move on X axis
                                center: 400         // Center point on X axis
                            },      
                            y: { 
                                top: 'curiosity',    // Top = Open, Exploratory mindset
                                bottom: 'focus',     // Bottom = Concentrated, Focused attention
                                range: 250,          // How far YOU can move on Y axis
                                center: 300         // Center point on Y axis
                            }
                        },
                        
                        // Visual mapping parameters for additional consciousness dimensions
                        visualMappings: {
                            compassion: { 
                                type: 'color', 
                                high: '#50f0b0',    // Green for high compassion
                                medium: '#5fb8ff',  // Blue for medium compassion
                                low: '#ffa600'      // Orange for low compassion
                            },
                            hrv: { 
                                type: 'opacity', 
                                min: 0.4,           // Low HRV = more transparent
                                max: 1.0            // High HRV = fully opaque
                            },
                            coherence: { 
                                type: 'glow', 
                                min: 0,             // No glow when low coherence
                                max: 25             // Strong glow when high coherence
                            },
                            creativity: { 
                                type: 'size', 
                                min: 0.7,           // Smaller when low creativity
                                max: 1.5            // Larger when high creativity
                            },
                            resilience: {
                                type: 'stability',
                                min: 0.5,           // Shaky movement when low resilience
                                max: 1.0            // Steady when high resilience
                            }
                        }
                    },
                    
                    // Current spatial position based on consciousness state
                    userPosition: { x: 400, y: 300, state: 'balanced' },  // Start at center (balanced)
                    centerPosition: { x: 400, y: 300 },                   // The "perfect balance" point
                    
                    // Animation parameters enhanced with consciousness feedback
                    agentBehavior: 'idle',
                    animationParams: {
                        glow: 'normal',
                        pulse: false,
                        bridge_line: { show: false },
                        movement: { type: 'idle', pattern: 'gentle_drift' },
                        consciousness_feedback: { active: true, intensity: 'medium' }
                    }
                };

                // Stuck state detection system (enhanced με spatial awareness)
                this.stuckState = {
                    lastProgress: Date.now(),
                    lastAlignment: 0,
                    stagnationThreshold: 90000, // 1.5 minutes (90 seconds)
                    progressDropThreshold: 5, // 5% drop in alignment
                    isStuck: false,
                    stuckCount: 0,
                    interventionActive: false,
                    stuckPatterns: [], // For adaptive learning
                    spatialStagnation: false // NEW: Spatial movement stagnation
                };
                
                // Coach intervention system
                this.coachSystem = {
                    interventionTypes: ['visual_nudge', 'micro_feedback', 'difficulty_adjust', 'alternative_path', 'guided_exercise', 'sound_nudge'],
                    lastIntervention: null,
                    interventionHistory: [],
                    progressDiary: [], // Progress tracking
                    adaptiveLearning: {
                        userPatterns: {},
                        successfulInterventions: {},
                        preferredPaths: []
                    }
                };
                
                this.startTime = Date.now(); // Initialize startTime for engagement calculation
                this.init();
            }
            
            init() {
                // 🎯 EVIDENCE-BASED PERSONALITY EVOLUTION - AUTO-RESET WITHOUT SIGNAL
                const savedPersonality = localStorage.getItem('userPersonality');
                const shouldLoadSaved = savedPersonality && this.hasLiveSignal;
                
                if (!shouldLoadSaved && savedPersonality) {
                    console.log('🔄 AUTO-RESET: No live signal - clearing inflated localStorage values');
                    localStorage.removeItem('userPersonality');
                }
                
                this.userEvolution = {
                    currentPersonality: shouldLoadSaved ? JSON.parse(savedPersonality) : {
                        empathy: 0.5,
                        creativity: 0.5,
                        resilience: 0.5,
                        focus: 0.5,
                        curiosity: 0.5,
                        compassion: 0.5
                    },
                    evolutionHistory: [],
                    behavioralMarkers: {
                        compassionTasks: { completed: 0, totalTime: 0 },
                        creativeTasks: { timeSpent: 0, explorationCount: 0 },
                        focusTasks: { sustained: 0, deepSessions: 0 },
                        resilienceTasks: { recoveryTime: 0, overcomeChallenges: 0 }
                    },
                    biofeedbackCorrelations: {
                        hrvStability: 0.5,
                        coherenceTrends: [],
                        focusConsistency: 0.5
                    }
                };
                
                this.setCurrentTarget(0);
                this.startIntegratedSystems();
                this.setupInteractions();
                this.updateAllSystems();
                
                // FIXED: Update every 1.5 seconds with memory leak prevention
                this.mainUpdateInterval = setInterval(() => {
                    try {
                        this.updateAllSystems(); // This already includes personality evolution and spatial intelligence
                        this.processMemory();
                        this.detectStuckState(); // Detect if user is stuck (includes spatial stagnation)
                        
                        // ANTI-FREEZE ENHANCED: Force evolution panel update every 3 cycles (4.5 seconds) + immediate sync
                        if (!this.forceUpdateCounter) this.forceUpdateCounter = 0;
                        this.forceUpdateCounter++;
                        if (this.forceUpdateCounter >= 3) {
                            console.log('🔄 ANTI-FREEZE: Force updating evolution panel');
                            this.renderUserEvolution(true); // Force update = true
                            this.forceUpdateCounter = 0;
                        }
                        
                        // CONTINUOUS SYNC: Always try to render if we have new personality data
                        if (this.consciousnessMapping && this.consciousnessMapping.personality) {
                            this.renderUserEvolution();
                        }
                        
                        // 🚫 TEST DISABLED - No more artificial inflation of Evolution bars
                        // if (this.forceUpdateCounter === 1) {
                        //     this.testEvolutionPanelUpdate();
                        // }
                        
                    } catch (error) {
                        console.warn('⚠️ Update cycle error:', error);
                        // Don't let errors break the update loop
                    }
                }, 1500); // Reduced from 2000ms to 1500ms
                
                // Initialize spatial intelligence system
                console.log('🧬 Spatial Intelligence System - CENTER-LOSS DETECTION Active');
                console.log('📊 Real-time monitoring: User position, distance thresholds, agent recall behavior');
                
                // Log initial spatial state
                console.log('Initial Spatial State:', {
                    threshold: this.spatialIntelligence.threshold,
                    riskLevel: this.spatialIntelligence.riskLevel,
                    agentBehavior: this.spatialIntelligence.agentBehavior
                });
                
                // Also update on user interaction
                this.setupUserMovementTriggers();
                
                console.log('🧠 User Evolution System initialized');
            }
            
            setupUserMovementTriggers() {
                // Click on USER element to boost metrics temporarily
                const userElement = document.getElementById('userState');
                if (userElement) {
                    userElement.addEventListener('click', () => {
                        // ✅ CHECK SIGNAL BEFORE USER CLICK BOOST
                        if (this.hasLiveSignal) {
                            // 🚫 UI BOOST DISABLED - No artificial metric inflation in production
                            // this.systemMetrics.soul.coherence = Math.min(100, this.systemMetrics.soul.coherence + 15);
                            // this.systemMetrics.soul.vitality = Math.min(100, this.systemMetrics.soul.vitality + 10);
                            // this.systemMetrics.hrv.coherence = Math.min(100, this.systemMetrics.hrv.coherence + 12);
                            // this.systemMetrics.hrv.focus = Math.min(100, this.systemMetrics.hrv.focus + 8);
                            console.log('🎯 YOU element clicked - only authentic TICKR data drives motion');
                        } else {
                            console.log('🚫 SIGNAL LOST - YOU click ignored');
                        }
                        
                        // Force immediate recalculation and movement
                        this.calculateAlignment();
                    });
                }
                
                // Click on centers also affects movement
                this.centers.forEach((center, index) => {
                    const element = document.getElementById(center.id);
                    if (element) {
                        element.addEventListener('click', () => {
                            if (index === this.currentTargetIndex) {
                                // ✅ CHECK SIGNAL BEFORE CENTER CLICK BOOST
                                if (this.hasLiveSignal) {
                                    // 🚫 UI BOOST DISABLED - No artificial metric inflation in production  
                                    // this.systemMetrics.soul.coherence += 20;
                                    // this.systemMetrics.hrv.focus += 15;
                                    console.log('🎯 Center clicked - only authentic TICKR data drives metrics');
                                    this.calculateAlignment(); // Triggers movement
                                } else {
                                    console.log('🚫 SIGNAL LOST - Skipping center click boost');
                                }
                            }
                        });
                    }
                });
            }
            
            updateAllSystems() {
                // Store previous center time for behavioral analysis
                if (!this.lastCenterTime) {
                    this.lastCenterTime = Date.now();
                }
                
                // 🎯 UNIFIED SIGNAL CONTROL - Αυτόματο freeze + μηδενισμός εσωτερικών τιμών
                const live = this.hasLiveSignal === true;
                this.motionFrozen = !live;
                
                if (!live) {
                    console.log('🚫 NO LIVE SIGNAL - Zeroing all internal metrics');
                    this.systemMetrics.soul.coherence = 0;
                    this.systemMetrics.soul.vitality = 0;
                    this.systemMetrics.soul.ethics = 0;
                    this.systemMetrics.soul.narrative = 0;
                    // 🎯 HRV shows N/A when no signal
                    this.systemMetrics.hrv.hrv = null;
                    this.systemMetrics.hrv.breath = null;
                    this.systemMetrics.hrv.coherence = 0;
                    this.systemMetrics.hrv.focus = 0;
                }
                // NOTE: Soul Metrics are updated only via neural polling, NOT HERE
                
                // NOTE: HRV Biometrics are updated only via neural polling, NOT HERE
                
                // Update Memory System
                this.systemMetrics.memory.items = this.memoryItems.length;
                this.systemMetrics.memory.retention = 90 + Math.random() * 10;
                
                // UPDATE USER PERSONALITY EVOLUTION - Fixed timing conflicts
                const currentTime = Date.now();
                if (!this.lastPersonalityUpdate || currentTime - this.lastPersonalityUpdate > 2000) {
                    this.updateUserPersonality();
                    this.lastPersonalityUpdate = currentTime;
                    
                    // FORCE IMMEDIATE UI UPDATE to prevent freezing
                    this.renderUserEvolution();
                }
                
                // Update UI
                this.updateSystemUI();
                this.calculateAlignment();
                
                // NEW: Update Spatial Intelligence
                this.updateSpatialIntelligence();
            }
            
            updateSystemUI() {
                // 🚫 CRITICAL: Don't update if metrics are locked due to no signal
                if (this.metricsLocked) {
                    console.log('🚫 METRICS LOCKED - Skipping UI update');
                    return;
                }
                
                // Soul Metrics - Εμφάνιση μόνο με live signal
                const live = this.hasLiveSignal === true;
                const coherence = live ? this.systemMetrics.soul.coherence : 0;
                const vitality = live ? this.systemMetrics.soul.vitality : 0;
                const ethics = live ? this.systemMetrics.soul.ethics : 0;
                const narrative = live ? this.systemMetrics.soul.narrative : 0;
                
                document.getElementById('coherenceScore').textContent = coherence.toFixed(0) + '%';
                document.getElementById('vitalityScore').textContent = vitality.toFixed(0) + '%';
                document.getElementById('ethicsScore').textContent = ethics.toFixed(0) + '%';
                document.getElementById('narrativeScore').textContent = narrative.toFixed(0) + '%';
                
                // Update Soul Metrics Bars
                document.getElementById('coherenceBar').style.width = coherence + '%';
                document.getElementById('vitalityBar').style.width = vitality + '%';
                document.getElementById('ethicsBar').style.width = ethics + '%';
                document.getElementById('narrativeBar').style.width = narrative + '%';
                
                // HRV Biometrics - Check for null values first
                const hrvValue = this.systemMetrics.hrv.hrv;
                const breathValue = this.systemMetrics.hrv.breath;
                const coherenceValue = this.systemMetrics.hrv.coherence;
                const focusValue = this.systemMetrics.hrv.focus;
                
                document.getElementById('hrvValue').textContent = hrvValue !== null ? hrvValue.toFixed(1) + 'ms' : 'N/A';
                document.getElementById('breathRate').textContent = breathValue !== null ? breathValue.toFixed(1) + '/min' : 'N/A';
                document.getElementById('hrvCoherence').textContent = coherenceValue !== null ? coherenceValue.toFixed(0) + '%' : 'N/A';
                document.getElementById('focusValue').textContent = focusValue !== null ? focusValue.toFixed(0) + '%' : 'N/A';
                
                // Memory System
                document.getElementById('memoryItems').textContent = this.systemMetrics.memory.items;
                document.getElementById('memoryRetention').textContent = this.systemMetrics.memory.retention.toFixed(0) + '%';
                
                // Anomaly Detection
                document.getElementById('behaviorStatus').textContent = this.systemMetrics.anomaly.behavior;
                document.getElementById('insightCount').textContent = this.systemMetrics.anomaly.insights;
                
                // 🎯 EVIDENCE-BASED EVOLUTION BARS - Confidence gated display
                this.updateEvolutionBarsWithConfidence();
                // AI bars disabled until GPT integration
                // this.updatePersonalityBars();
            }
            
            updatePersonalityBars() {
                // Update AI personality traits with dynamic values
                const personalityTraits = ['empathy', 'analytical', 'curiosity'];
                personalityTraits.forEach(trait => {
                    const element = document.getElementById(`${trait}Trait`);
                    const barElement = document.getElementById(`${trait}Bar`);
                    
                    if (element && barElement) {
                        // Generate dynamic values based on current center and metrics
                        let value = 0.5 + (this.currentTargetIndex * 0.05) + (Math.random() * 0.2 - 0.1);
                        value = Math.max(0.3, Math.min(0.9, value)); // Keep between 30-90%
                        
                        element.textContent = value.toFixed(2);
                        barElement.style.width = (value * 100) + '%';
                    }
                });
            }
            
            evolvePersonality() {
                // Simulate personality evolution based on book center interaction
                if (this.currentTargetIndex < this.centers.length) {
                    const center = this.centers[this.currentTargetIndex];
                    
                    // Update personality traits based on current center
                    const empathyElement = document.getElementById('empathyTrait');
                    const analyticalElement = document.getElementById('analyticalTrait');
                    const curiosityElement = document.getElementById('curiosityTrait');
                    
                    if (center.name.includes('COMPASSION') || center.name.includes('EMPATHY')) {
                        empathyElement.textContent = (parseFloat(empathyElement.textContent) + 0.01).toFixed(2);
                    }
                    if (center.name.includes('MINDFULNESS') || center.name.includes('AWARENESS')) {
                        analyticalElement.textContent = (parseFloat(analyticalElement.textContent) + 0.01).toFixed(2);
                    }
                    if (center.name.includes('INTERCONNECTEDNESS') || center.name.includes('INNER')) {
                        curiosityElement.textContent = (parseFloat(curiosityElement.textContent) + 0.01).toFixed(2);
                    }
                }
            }
            
            processMemory() {
                // Add memory items based on current experience
                if (this.currentTargetIndex < this.centers.length) {
                    const center = this.centers[this.currentTargetIndex];
                    const timestamp = new Date().toLocaleTimeString();
                    
                    const memoryItem = {
                        content: `Engaging with ${center.name}: ${center.description}`,
                        timestamp: timestamp,
                        centerIndex: this.currentTargetIndex
                    };
                    
                    this.memoryItems.push(memoryItem);
                    
                    if (this.memoryItems.length > 10) {
                        this.memoryItems.shift(); // Keep only last 10 items
                    }
                    
                    this.updateMemoryStream();
                }
            }
            
            updateMemoryStream() {
                const streamContent = document.getElementById('memoryStreamContent');
                streamContent.innerHTML = '';
                
                this.memoryItems.slice(-5).forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'memory-item';
                    div.innerHTML = `
                        ${item.content}
                        <div class="memory-timestamp">${item.timestamp}</div>
                    `;
                    streamContent.appendChild(div);
                });
            }
            
            setCurrentTarget(index) {
                // Remove old target
                if (this.currentTargetIndex < this.centers.length) {
                    const oldTarget = document.getElementById(this.centers[this.currentTargetIndex].id);
                    if (oldTarget) oldTarget.classList.remove('target');
                }
                
                // Set new target
                this.currentTargetIndex = index;
                if (index < this.centers.length) {
                    const center = this.centers[index];
                    const element = document.getElementById(center.id);
                    if (element) {
                        element.classList.add('target');
                        document.getElementById('currentChapter').textContent = `Target: ${center.name}`;
                    }
                }
            }
            
            calculateAlignment() {
                if (this.currentTargetIndex >= this.centers.length) return;
                
                const currentTraits = this.userEvolution.currentPersonality;
                
                // 🧠 MAP CONSCIOUSNESS TO SPATIAL POSITION - The "Inner Map"
                const consciousnessPosition = this.mapConsciousnessToSpace(currentTraits);
                
                // Update spatial intelligence with consciousness mapping
                this.spatialIntelligence.userPosition = consciousnessPosition;
                this.spatialIntelligence.currentDistance = consciousnessPosition.distanceFromCenter / 100; // Normalize
                
                // Calculate integrated alignment score - Μόνο με live signal
                const live = this.hasLiveSignal === true;
                const soulAvg = live 
                    ? (this.systemMetrics.soul.coherence + this.systemMetrics.soul.vitality + 
                       this.systemMetrics.soul.ethics + this.systemMetrics.soul.narrative) / 4
                    : 0;
                const hrvAvg = (this.systemMetrics.hrv.coherence + this.systemMetrics.hrv.focus) / 2;
                const memoryScore = this.systemMetrics.memory.retention;
                
                const integratedAlignment = (soulAvg * 0.4 + hrvAvg * 0.4 + memoryScore * 0.2);
                
                document.getElementById('alignmentScore').textContent = integratedAlignment.toFixed(0) + '%';
                
                // Move USER based on consciousness mapping (revolutionary spatial intelligence)
                this.moveUserToConsciousnessPosition(consciousnessPosition);
                
                // Update spatial intelligence and check for center loss
                this.updateSpatialIntelligence();
                
                // Check for stuck patterns in consciousness space
                this.detectStuckState();
                
                // Check for center unlock
                if (integratedAlignment > 85) {
                    this.unlockCurrentCenter();
                }
                
                return integratedAlignment;
            }
            
            moveUserBasedOnMetrics(alignment, soulAvg, hrvAvg) {
                const userElement = document.getElementById('userState');
                const currentCenter = this.centers[this.currentTargetIndex];
                
                if (!currentCenter || !userElement) return;
                
                // Calculate movement based on real metrics
                const soulFactor = soulAvg / 100;  // 0-1 scale
                const hrvFactor = hrvAvg / 100;    // 0-1 scale
                const alignmentFactor = alignment / 100; // 0-1 scale
                
                // Dynamic positioning based on metrics
                const baseLeft = 10; // Starting position
                const baseTop = 45;
                
                // Move towards target center based on alignment
                const targetLeft = parseFloat(currentCenter.position.left);
                const targetTop = parseFloat(currentCenter.position.top);
                
                // Interpolate position based on alignment score
                const newLeft = baseLeft + (targetLeft - baseLeft) * alignmentFactor * 0.8;
                const newTop = baseTop + (targetTop - baseTop) * alignmentFactor * 0.6;
                
                // Apply movement with smooth transition
                userElement.style.left = newLeft + '%';
                userElement.style.top = newTop + '%';
                
                // Visual feedback based on different metrics
                if (soulFactor > 0.9) {
                    userElement.style.boxShadow = '0 0 40px rgba(34, 197, 94, 0.8)'; // Green glow
                } else if (hrvFactor > 0.8) {
                    userElement.style.boxShadow = '0 0 30px rgba(59, 130, 246, 0.6)'; // Blue glow
                } else if (alignmentFactor > 0.7) {
                    userElement.style.boxShadow = '0 0 25px rgba(255, 255, 255, 0.4)'; // White glow
                } else {
                    userElement.style.boxShadow = '0 0 15px rgba(255, 255, 255, 0.2)'; // Dim glow
                }
                
                // Rotate slightly based on coherence (only with live signal)
                const live = this.hasLiveSignal === true;
                const coherence = live ? this.systemMetrics.soul.coherence : 50;
                const rotation = (coherence - 50) * 0.5; // -25 to +25 degrees
                userElement.style.transform = `rotate(${rotation}deg) scale(${0.8 + alignmentFactor * 0.4})`;
                
                // Update connection line to show progress
                this.updateConnectionLine(userElement, currentCenter);
            }
            
            updateConnectionLine(userElement, targetCenter) {
                const connectionLine = document.getElementById('connectionLine');
                if (!connectionLine || !userElement) return;
                
                const userRect = userElement.getBoundingClientRect();
                const targetElement = document.getElementById(targetCenter.id);
                if (!targetElement) return;
                
                const targetRect = targetElement.getBoundingClientRect();
                
                // Calculate line position and angle
                const deltaX = targetRect.left - userRect.left;
                const deltaY = targetRect.top - userRect.top;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
                
                // Position and style the connection line
                connectionLine.style.left = userRect.left + 'px';
                connectionLine.style.top = userRect.top + userRect.height/2 + 'px';
                connectionLine.style.width = distance + 'px';
                connectionLine.style.transform = `rotate(${angle}deg)`;
                connectionLine.classList.add('active');
                
                // Line intensity based on alignment
                const alignment = parseFloat(document.getElementById('alignmentScore').textContent);
                connectionLine.style.opacity = Math.min(1, alignment / 100);
            }
            
            unlockCurrentCenter() {
                if (this.currentTargetIndex >= this.centers.length) return;
                
                const center = this.centers[this.currentTargetIndex];
                const centerElement = document.getElementById(center.id);
                
                if (centerElement && !centerElement.classList.contains('locked')) {
                    centerElement.classList.remove('target');
                    centerElement.classList.add('locked');
                    
                    // Record achievement in memory
                    this.memoryItems.push({
                        content: `🎉 Unlocked ${center.name} - Wisdom integrated!`,
                        timestamp: new Date().toLocaleTimeString(),
                        centerIndex: this.currentTargetIndex,
                        achievement: true
                    });
                    
                    // Update anomaly insights
                    this.systemMetrics.anomaly.insights++;
                    
                    // Move to next center
                    setTimeout(() => {
                        this.moveToNextCenter();
                    }, 2000);
                }
            }
            
            moveToNextCenter() {
                const nextIndex = this.currentTargetIndex + 1;
                
                if (nextIndex < this.centers.length) {
                    this.setCurrentTarget(nextIndex);
                } else {
                    document.getElementById('currentChapter').textContent = '🎉 All Centers Unlocked!';
                    this.systemMetrics.anomaly.behavior = 'Transcendent';
                }
            }
            
            setupInteractions() {
                // Center interactions
                this.centers.forEach((center, index) => {
                    const element = document.getElementById(center.id);
                    if (element) {
                        element.addEventListener('click', () => {
                            if (index === this.currentTargetIndex) {
                                // 🚫 UI BOOST DISABLED - No artificial metric inflation in production
                                // this.systemMetrics.soul.coherence += 10;
                                // this.systemMetrics.hrv.focus += 15;
                                // this.systemMetrics.memory.retention += 5;
                                console.log('🎯 Interactive center clicked - only authentic data matters');
                            }
                        });
                    }
                });
            }
            
            // INTELLIGENT STUCK STATE DETECTION
            detectStuckState() {
                const now = Date.now();
                const currentAlignment = parseFloat(document.getElementById('alignmentScore').textContent) || 0;
                
                // Check for stagnation (no progress for X seconds)
                const timeSinceProgress = now - this.stuckState.lastProgress;
                const alignmentDrop = this.stuckState.lastAlignment - currentAlignment;
                
                // Detect stuck conditions
                if (timeSinceProgress > this.stuckState.stagnationThreshold || alignmentDrop > this.stuckState.progressDropThreshold) {
                    if (!this.stuckState.isStuck) {
                        this.stuckState.isStuck = true;
                        this.stuckState.stuckCount++;
                        this.triggerCoachIntervention();
                    }
                } else if (currentAlignment > this.stuckState.lastAlignment + 2) {
                    // Progress detected - reset stuck state
                    this.stuckState.isStuck = false;
                    this.stuckState.lastProgress = now;
                    this.stuckState.interventionActive = false;
                }
                
                this.stuckState.lastAlignment = currentAlignment;
            }
            
            // INTELLIGENT COACH INTERVENTION SYSTEM
            triggerCoachIntervention() {
                if (this.stuckState.interventionActive) return;
                
                this.stuckState.interventionActive = true;
                
                // Choose intervention based on stuck count and history
                let interventionType;
                if (this.stuckState.stuckCount === 1) {
                    interventionType = 'visual_nudge';
                } else if (this.stuckState.stuckCount === 2) {
                    interventionType = 'micro_feedback';
                } else if (this.stuckState.stuckCount === 3) {
                    interventionType = 'difficulty_adjust';
                } else if (this.stuckState.stuckCount >= 4) {
                    interventionType = 'alternative_path';
                }
                
                this.executeIntervention(interventionType);
            }
            
            executeIntervention(type) {
                const currentCenter = this.centers[this.currentTargetIndex];
                if (!currentCenter) return;
                
                switch(type) {
                    case 'visual_nudge':
                        this.visualNudge(currentCenter);
                        break;
                    case 'micro_feedback':
                        this.microFeedback();
                        break;
                    case 'difficulty_adjust':
                        this.adjustDifficulty();
                        break;
                    case 'alternative_path':
                        this.showAlternativePath();
                        break;
                    case 'guided_exercise':
                        this.guidedExercise();
                        break;
                }
                
                this.coachSystem.lastIntervention = type;
                this.coachSystem.interventionHistory.push({
                    type: type,
                    timestamp: Date.now(),
                    targetCenter: currentCenter.name
                });
            }
            
            // VISUAL NUDGE - Make target center more attractive
            visualNudge(center) {
                const centerElement = document.getElementById(center.id);
                if (!centerElement) return;
                
                // Enhanced pulsing animation
                centerElement.style.animation = 'targetPulse 1s ease-in-out infinite, attractPulse 2s ease-in-out infinite';
                centerElement.style.boxShadow = '0 0 50px rgba(255, 255, 255, 0.8), 0 0 100px rgba(255, 255, 255, 0.4)';
                
                // Show encouragement message in ENGLISH
                this.showCoachMessage("The center is calling you... Relax and let yourself move towards it ⭐");
                this.playSoundNudge('attract');
                
                // Record pattern for adaptive learning
                this.recordStuckPattern('visual_nudge');
                
                setTimeout(() => {
                    centerElement.style.animation = 'targetPulse 2s ease-in-out infinite';
                    centerElement.style.boxShadow = '';
                }, 5000);
            }
            
            // MICRO FEEDBACK - Gentle guidance in ENGLISH
            microFeedback() {
                const messages = [
                    "Take a deep breath... The center is calling you ⭐",
                    "Relax your shoulders... Let yourself flow towards it 🌊", 
                    "Close your eyes and simply feel... You're doing great 🧘",
                    "It's okay, I'm here for you... Progress over perfection ✨",
                    "The journey matters more than the destination... Keep going 💙",
                    "Feel the center's energy drawing you in... Trust the process 🌟",
                    "Release any tension... Let your natural flow guide you 🕯️"
                ];
                
                const randomMessage = messages[Math.floor(Math.random() * messages.length)];
                this.showCoachMessage(randomMessage);
                this.playSoundNudge('gentle');
                
                // Record pattern for adaptive learning
                this.recordStuckPattern('micro_feedback');
                
                // Temporarily boost metrics to help
                this.systemMetrics.hrv.coherence += 5;
                this.systemMetrics.soul.vitality += 3;
            }
            
            // DIFFICULTY ADJUST - Make target easier temporarily
            adjustDifficulty() {
                const centerElement = document.getElementById(this.centers[this.currentTargetIndex].id);
                if (!centerElement) return;
                
                // Make center bigger temporarily
                centerElement.style.transform = 'scale(1.4)';
                centerElement.style.opacity = '0.9';
                
                this.showCoachMessage("Making this easier for you... Take your time, no rush! 🎯");
                this.playSoundNudge('support');
                
                // Record adaptive learning data
                this.recordStuckPattern('difficulty_adjust');
                this.updateProgressDiary('Difficulty adjusted - user needed larger target');
                
                setTimeout(() => {
                    centerElement.style.transform = '';
                    centerElement.style.opacity = '';
                }, 10000);
            }
            
            // ALTERNATIVE PATH - Show different center temporarily
            showAlternativePath() {
                if (this.currentTargetIndex > 0) {
                    const alternativeIndex = Math.max(0, this.currentTargetIndex - 1);
                    const alternativeCenter = this.centers[alternativeIndex];
                    const altElement = document.getElementById(alternativeCenter.id);
                    
                    if (altElement) {
                        altElement.style.border = '3px dashed rgba(34, 197, 94, 0.8)';
                        altElement.style.animation = 'alternativePulse 2s ease-in-out infinite';
                        
                        this.showCoachMessage(`Try "${alternativeCenter.name}" first... Sometimes a side step leads us forward! 🔄`);
                        this.playSoundNudge('alternative');
                        
                        // Record personalized pathway
                        this.recordPersonalizedPath(alternativeCenter.name);
                        this.updateProgressDiary(`Alternative path suggested: ${alternativeCenter.name}`);
                        
                        setTimeout(() => {
                            altElement.style.border = '';
                            altElement.style.animation = '';
                        }, 8000);
                    }
                }
            }
            
            // COACH MESSAGE DISPLAY SYSTEM
            showCoachMessage(message) {
                // Create or update coach message element
                let coachElement = document.getElementById('coachMessage');
                if (!coachElement) {
                    coachElement = document.createElement('div');
                    coachElement.id = 'coachMessage';
                    coachElement.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(0, 0, 0, 0.9);
                        color: white;
                        padding: 20px 30px;
                        border-radius: 15px;
                        border: 2px solid rgba(34, 197, 94, 0.6);
                        font-size: 16px;
                        text-align: center;
                        z-index: 1000;
                        max-width: 400px;
                        animation: coachFadeIn 0.5s ease-in-out;
                        box-shadow: 0 0 30px rgba(34, 197, 94, 0.3);
                    `;
                    document.body.appendChild(coachElement);
                }
                
                coachElement.textContent = message;
                coachElement.style.display = 'block';
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    if (coachElement) {
                        coachElement.style.animation = 'coachFadeOut 0.5s ease-in-out';
                        setTimeout(() => {
                            coachElement.style.display = 'none';
                        }, 500);
                    }
                }, 5000);
            }
            
            // SOUND NUDGE SYSTEM
            playSoundNudge(type) {
                // Create audio context if not exists
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const frequencies = {
                    'gentle': 432, // Calming frequency
                    'attract': 528, // Love frequency  
                    'support': 396, // Liberating guilt/fear
                    'alternative': 741 // Awakening intuition
                };
                
                const freq = frequencies[type] || 432;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 1);
            }
            
            // ADAPTIVE LEARNING SYSTEM
            recordStuckPattern(interventionType) {
                const pattern = {
                    timestamp: Date.now(),
                    center: this.centers[this.currentTargetIndex].name,
                    intervention: interventionType,
                    metricsAtTime: { ...this.systemMetrics }
                };
                
                this.stuckState.stuckPatterns.push(pattern);
                
                // Learn from successful interventions
                if (!this.coachSystem.adaptiveLearning.successfulInterventions[interventionType]) {
                    this.coachSystem.adaptiveLearning.successfulInterventions[interventionType] = 0;
                }
                this.coachSystem.adaptiveLearning.successfulInterventions[interventionType]++;
            }
            
            recordPersonalizedPath(centerName) {
                if (!this.coachSystem.adaptiveLearning.preferredPaths.includes(centerName)) {
                    this.coachSystem.adaptiveLearning.preferredPaths.push(centerName);
                }
            }
            
            // PROGRESS DIARY SYSTEM
            updateProgressDiary(entry) {
                const diaryEntry = {
                    timestamp: new Date().toISOString(),
                    entry: entry,
                    currentCenter: this.centers[this.currentTargetIndex].name,
                    metrics: { ...this.systemMetrics },
                    stuckCount: this.stuckState.stuckCount
                };
                
                this.coachSystem.progressDiary.push(diaryEntry);
                
                // Keep only last 50 entries
                if (this.coachSystem.progressDiary.length > 50) {
                    this.coachSystem.progressDiary.shift();
                }
            }
            
            // USER EVOLUTION TRACKING SYSTEM
            updateUserPersonality() {
                // 🛡️ SAFETY CHECK: Μην επηρεάζεις evolution όταν δεν έχεις live signal
                if (!this.hasLiveSignal) return;
                
                // Behavioral analysis based on actions
                this.analyzeUserBehavior();
                
                // Biofeedback correlation
                this.correlateBiofeedback();
                
                // Update UI with new scores
                this.renderUserEvolution();
                
                // Log evolution for history
                this.logEvolutionChange();
            }
            
            analyzeUserBehavior() {
                const currentCenter = this.centers[this.currentTargetIndex];
                
                // 🎯 CONFIDENCE-GATED EVOLUTION - Only with validated evidence
                this.updateEvolutionConfidence();
                
                // 🧠 EVIDENCE-BASED Empathy - STRICT CONFIDENCE REQUIREMENTS
                if (currentCenter.name.includes('COMPASSION') || currentCenter.name.includes('FORGIVENESS') || currentCenter.name.includes('LOVE')) {
                    if (this.systemMetrics.hrv.coherence > 75 && this.evolutionEvidence.confidenceLevel > 0.4) {
                        const increment = 0.004 * this.evolutionEvidence.confidenceLevel; // Reduced rate  
                        this.userEvolution.currentPersonality.empathy += increment;
                        this.userEvolution.currentPersonality.compassion += increment * 1.2;
                        console.log('📊 EVIDENCE-BASED empathy growth:', increment.toFixed(4));
                    }
                    this.userEvolution.behavioralMarkers.compassionTasks.completed++;
                }
                
                // 🧠 EVIDENCE-BASED Creativity evolution - requires sustained vitality
                if (currentCenter.name.includes('CREATIVITY') || currentCenter.name.includes('AWARENESS') || currentCenter.name.includes('INNER')) {
                    // 🎯 DISABLED: Too frequent triggering - need sustained metrics over time
                    // if (this.systemMetrics.soul.vitality > 70) {
                    //     this.userEvolution.currentPersonality.creativity += 0.01;
                    // }
                    this.userEvolution.behavioralMarkers.creativeTasks.timeSpent += Date.now() - this.lastCenterTime;
                }
                
                // 🧠 EVIDENCE-BASED Focus evolution - requires sustained focus metrics  
                if (currentCenter.name.includes('PRESENCE') || currentCenter.name.includes('MINDFULNESS') || currentCenter.name.includes('FOCUS')) {
                    // 🎯 DISABLED: Too frequent triggering - need sustained focus over time
                    // if (this.systemMetrics.hrv.focus > 65) {
                    //     this.userEvolution.currentPersonality.focus += 0.009;
                    // }
                    this.userEvolution.behavioralMarkers.focusTasks.sustained++;
                }
                
                // 🧠 EVIDENCE-BASED Resilience - ONLY FROM OVERCOMING REAL CHALLENGES
                if (this.stuckState.stuckCount > 0 && !this.stuckState.isStuck && this.evolutionEvidence.confidenceLevel > 0.5) {
                    const resilience_increment = 0.004 * this.evolutionEvidence.confidenceLevel;
                    this.userEvolution.currentPersonality.resilience += resilience_increment;
                    console.log('💪 EVIDENCE-BASED resilience from challenge:', resilience_increment.toFixed(4));
                    this.userEvolution.behavioralMarkers.resilienceTasks.recoveryTime = Date.now() - this.stuckState.lastProgress;
                }
                // 🚫 NO passive resilience growth from coherence alone
                
                // 🧠 EVIDENCE-BASED Curiosity - SUSTAINED EXPLORATION REQUIRED
                const explorationThreshold = 30000; // 30 seconds sustained 
                if (this.userEvolution.behavioralMarkers.creativeTasks.timeSpent > explorationThreshold && 
                    this.systemMetrics.soul.narrative > 80 && this.evolutionEvidence.confidenceLevel > 0.3) {
                    const curiosity_increment = 0.003 * this.evolutionEvidence.confidenceLevel;
                    this.userEvolution.currentPersonality.curiosity += curiosity_increment;
                    console.log('🔍 EVIDENCE-BASED curiosity from exploration:', curiosity_increment.toFixed(4));
                }
                
                // HOMEOSTASIS - Ήπια έλξη προς ισορροπία αντί για μόνιμη αύξηση
                const target = 0.5, k = 0.004; // ήπια έλξη προς 0.5
                Object.keys(this.userEvolution.currentPersonality).forEach(trait => {
                    const cur = this.userEvolution.currentPersonality[trait] ?? 0.5;
                    const next = cur + (target - cur) * k;  // μικρή επαναφορά
                    this.userEvolution.currentPersonality[trait] = Math.max(0, Math.min(1, next));
                });
                
                // 🔒 CONDITIONAL SAVE - Only save if we have confidence
                if (this.evolutionEvidence.confidenceLevel > 0.2) {
                    localStorage.setItem('userPersonality', JSON.stringify(this.userEvolution.currentPersonality));
                    console.log('💾 Saved personality with confidence:', this.evolutionEvidence.confidenceLevel.toFixed(2));
                } else {
                    console.log('🚫 Low confidence - not saving personality changes');
                }
            }
            
            // 🧠 EVIDENCE ACCUMULATION TRACKING
            trackEvidenceAccumulation(currentCenter, now) {
                // Only track if we have live signal
                if (!this.hasLiveSignal) return false;
                
                // Update last evidence time
                this.evolutionEvidence.lastEvidenceTime = now;
                
                // Calculate valid minutes since session start
                const sessionMinutes = (now - this.evolutionEvidence.sessionStart) / (1000 * 60);
                this.evolutionEvidence.validMinutes = sessionMinutes;
                
                return true; // Evidence valid
            }
            
            // 🎯 CONFIDENCE LEVEL CALCULATION
            updateEvolutionConfidence() {
                if (!this.hasLiveSignal) {
                    this.evolutionEvidence.confidenceLevel = 0;
                    return;
                }
                
                // Calculate confidence based on accumulated valid minutes
                const ratio = this.evolutionEvidence.validMinutes / this.evolutionEvidence.minValidMinutes;
                this.evolutionEvidence.confidenceLevel = Math.min(1.0, Math.max(0, ratio));
                
                console.log(`🎯 Evolution confidence: ${(this.evolutionEvidence.confidenceLevel * 100).toFixed(1)}% (${this.evolutionEvidence.validMinutes.toFixed(1)}min)`);
            }
            
            // 🧠 EVIDENCE-BASED EVOLUTION BARS - CONFIDENCE GATING
            updateEvolutionBarsWithConfidence() {
                const userTraits = ['empathy', 'creativity', 'resilience', 'focus', 'curiosity', 'compassion'];
                
                userTraits.forEach(trait => {
                    const scoreElement = document.getElementById(`user${trait.charAt(0).toUpperCase() + trait.slice(1)}Score`);
                    const barElement = document.getElementById(`user${trait.charAt(0).toUpperCase() + trait.slice(1)}Bar`);
                    
                    if (scoreElement && barElement && this.userEvolution.currentPersonality[trait] !== undefined) {
                        const rawScore = this.userEvolution.currentPersonality[trait];
                        
                        // 🎯 CONFIDENCE GATING - displayedScore = baseline + (rawScore - baseline) * confidence
                        const confidenceLevel = this.evolutionEvidence.confidenceLevel || 0;
                        
                        // Hard clamp without evidence: Keep in 45-55% range until ≥3 min evidence
                        let displayedScore;
                        if (confidenceLevel < 0.1) {
                            displayedScore = 0.5; // Default neutral
                        } else if (confidenceLevel < 1.0) {
                            // Blend between baseline and actual score based on confidence
                            displayedScore = 0.5 + (rawScore - 0.5) * confidenceLevel;
                            // Soft clamp to 45-55% until more evidence
                            const clampMin = Math.max(0.45, 0.5 - 0.05 * (1 - confidenceLevel));
                            const clampMax = Math.min(0.55, 0.5 + 0.05 * (1 - confidenceLevel));
                            displayedScore = Math.max(clampMin, Math.min(clampMax, displayedScore));
                        } else {
                            displayedScore = rawScore; // Full confidence, show actual score
                        }
                        
                        const percentage = Math.floor(displayedScore * 100);
                        scoreElement.textContent = `${percentage}%`;
                        barElement.style.width = `${percentage}%`;
                        
                        // 📊 Visual indicator for low confidence
                        if (confidenceLevel < 0.3) {
                            barElement.style.opacity = '0.6';
                            barElement.style.filter = 'grayscale(20%)';
                        } else {
                            barElement.style.opacity = '1.0';
                            barElement.style.filter = 'none';
                        }
                    }
                });
            }
            
            correlateBiofeedback() {
                // HRV stability correlates with emotional regulation (empathy/resilience)
                this.userEvolution.biofeedbackCorrelations.hrvStability = this.systemMetrics.hrv.coherence / 100;
                
                // Coherence trends for creativity/focus
                this.userEvolution.biofeedbackCorrelations.coherenceTrends.push(this.systemMetrics.soul.coherence);
                if (this.userEvolution.biofeedbackCorrelations.coherenceTrends.length > 10) {
                    this.userEvolution.biofeedbackCorrelations.coherenceTrends.shift();
                }
                
                // Focus consistency
                this.userEvolution.biofeedbackCorrelations.focusConsistency = this.systemMetrics.hrv.focus / 100;
            }
            
            renderUserEvolution(forceUpdate = false) {
                // ANTI-FREEZE FIX: Eliminate aggressive debouncing that causes panel freezing
                const currentTime = Date.now();
                if (!forceUpdate && this.lastEvolutionUpdate && currentTime - this.lastEvolutionUpdate < 50) {
                    return; // Reduced from 200ms to 50ms for ultra-responsive updates
                }
                this.lastEvolutionUpdate = currentTime;
                
                // DATA FLOW FIX: Bridge backend personality data to frontend userEvolution
                this.syncPersonalityDataFromBackend();
                
                const traits = ['empathy', 'creativity', 'resilience', 'focus', 'curiosity', 'compassion'];
                let updatedCount = 0;
                
                traits.forEach(trait => {
                    // SAFETY: Ensure personality data exists
                    if (!this.userEvolution?.currentPersonality) {
                        console.warn('⚠️ userEvolution.currentPersonality not initialized, using defaults');
                        this.initializePersonalityDefaults();
                    }
                    
                    const score = this.userEvolution.currentPersonality[trait] || 0.5; // Fallback to 50%
                    const percentage = Math.round(score * 100);
                    
                    const scoreElement = document.getElementById(`user${trait.charAt(0).toUpperCase() + trait.slice(1)}Score`);
                    const barElement = document.getElementById(`user${trait.charAt(0).toUpperCase() + trait.slice(1)}Bar`);
                    
                    if (scoreElement && barElement) {
                        // FORCE UPDATE - Override any stuck states with immediate DOM manipulation
                        try {
                            scoreElement.textContent = `${percentage}%`;
                            barElement.style.width = `${percentage}%`;
                            
                            // Enhanced visual feedback with error handling
                            if (score > 0.8) {
                                barElement.style.background = 'linear-gradient(90deg, #22c55e, #16a34a)';
                                barElement.style.boxShadow = '0 0 10px #22c55e50';
                            } else if (score > 0.5) {
                                barElement.style.background = 'linear-gradient(90deg, #3b82f6, #1d4ed8)';
                                barElement.style.boxShadow = '0 0 8px #3b82f650';
                            } else {
                                barElement.style.background = 'linear-gradient(90deg, #f59e0b, #d97706)';
                                barElement.style.boxShadow = '0 0 6px #f59e0b50';
                            }
                            
                            // Add pulsing animation for active changes
                            if (!this.lastPersonalityScores || Math.abs((this.lastPersonalityScores[trait] || 0.5) - score) > 0.01) {
                                barElement.style.animation = 'personalityPulse 0.8s ease-out';
                                setTimeout(() => {
                                    if (barElement) barElement.style.animation = 'none';
                                }, 800);
                            }
                            
                            updatedCount++;
                        } catch (error) {
                            console.error(`❌ Error updating ${trait} evolution panel:`, error);
                        }
                    } else {
                        console.warn(`⚠️ Missing DOM elements for ${trait}: score=${!!scoreElement}, bar=${!!barElement}`);
                    }
                });
                
                // Store last scores for change detection
                this.lastPersonalityScores = { ...this.userEvolution.currentPersonality };
                
                // SUCCESS LOG: Confirm updates are working
                if (updatedCount > 0) {
                    console.log(`✅ Evolution panel updated: ${updatedCount}/6 traits refreshed`, {
                        personality: this.userEvolution.currentPersonality,
                        consciousnessData: this.consciousnessMapping?.personality,
                        timestamp: currentTime
                    });
                } else {
                    console.warn('⚠️ Evolution panel: No traits updated', {
                        userEvolution: !!this.userEvolution,
                        currentPersonality: !!this.userEvolution?.currentPersonality,
                        consciousnessMapping: !!this.consciousnessMapping,
                        personalityData: this.consciousnessMapping?.personality
                    });
                }
                
                // HAWKINS THROTTLED LOGGING - 60s intervals + significant changes only
                this.logEvolutionSmarter(this.userEvolution.currentPersonality, currentTime);
            }
            
            // DATA BRIDGE: Sync backend consciousness data to frontend personality
            syncPersonalityDataFromBackend() {
                try {
                    // Check if we have recent consciousness data from backend
                    if (this.consciousnessMapping && this.consciousnessMapping.personality) {
                        // Map backend personality data to userEvolution format
                        Object.keys(this.consciousnessMapping.personality).forEach(trait => {
                            if (this.userEvolution?.currentPersonality && trait in this.userEvolution.currentPersonality) {
                                // Smooth transition: blend old and new values to prevent jarring jumps
                                const oldValue = this.userEvolution.currentPersonality[trait] || 0.5;
                                const newValue = this.consciousnessMapping.personality[trait];
                                const blendedValue = oldValue * 0.8 + newValue * 0.2; // 20% new data, 80% old for stability
                                
                                this.userEvolution.currentPersonality[trait] = Math.max(0, Math.min(1, blendedValue));
                            }
                        });
                    }
                    
                    // Also sync from any global personality updates
                    if (window.globalPersonalityUpdate) {
                        Object.assign(this.userEvolution.currentPersonality, window.globalPersonalityUpdate);
                        window.globalPersonalityUpdate = null; // Clear after use
                    }
                } catch (error) {
                    console.error('❌ Error syncing personality data from backend:', error);
                }
            }
            
            // 🗑️ TEST FUNCTION REMOVED - No longer needed, was artificially inflating Evolution bars
            
            // SAFETY: Initialize personality defaults if missing
            initializePersonalityDefaults() {
                if (!this.userEvolution) {
                    this.userEvolution = {};
                }
                if (!this.userEvolution.currentPersonality) {
                    this.userEvolution.currentPersonality = {
                        empathy: 0.5,
                        creativity: 0.5,
                        resilience: 0.5,
                        focus: 0.5,
                        curiosity: 0.5,
                        compassion: 0.5
                    };
                    console.log('🏗️ Initialized default personality values');
                }
            }
            
            // 🌟 UNIFIED SOUL+HRV HAWKINS SYSTEM - REVOLUTIONARY! 🌟
            initializeUnifiedConsciousness() {
                this.cHistory = []; // stores last 120 readings (2 minutes)
                this.cSmooth = null;
                this.lastAlertTime = 0;
                this.triggers = { up: [], down: [] };
            }
            
            // Normalize values to [0,1] range
            norm01(x) {
                if (x > 1) return Math.max(0.0, Math.min(1.0, x/100.0));
                return Math.max(0.0, Math.min(1.0, x));
            }
            
            // EMA smoothing function
            ema(prev, x, alpha = 0.3) {
                return alpha * x + (1 - alpha) * (prev !== null ? prev : x);
            }
            
            // Hawkins band mapping with thresholds
            hawkinsBand(C) {
                if (C < 0.20) return { level: 175, band: [0.00, 0.20], center: 0.10, state: '💪 Courage' };
                if (C < 0.35) return { level: 200, band: [0.20, 0.35], center: 0.275, state: '🎯 Willingness' };
                if (C < 0.50) return { level: 310, band: [0.35, 0.50], center: 0.425, state: '🤝 Acceptance' };
                if (C < 0.65) return { level: 400, band: [0.50, 0.65], center: 0.575, state: '🧠 Reason' };
                if (C < 0.80) return { level: 500, band: [0.65, 0.80], center: 0.725, state: '💖 Love' };
                return { level: 540, band: [0.80, 1.00], center: 0.90, state: '✨ Joy' };
            }
            
            // Sigmoid function for probability calculations
            sigmoid(z) {
                return 1 / (1 + Math.exp(-z));
            }
            
            // 🎯 MAIN UNIFIED CONSCIOUSNESS CALCULATOR
            calculateUnifiedConsciousness(personalityMetrics) {
                // Initialize if needed
                if (!this.cHistory) this.initializeUnifiedConsciousness();
                
                // Physical metrics (HRV + Focus + Breath)
                const phys = [
                    this.norm01(this.soulMetrics?.coherence || 80), // HRV coherence
                    this.norm01((personalityMetrics.focus || 0.5) * 100), // Focus
                    this.norm01(85) // Breath baseline (placeholder - can connect to real breath sensor)
                ];
                
                // Soul metrics (Coherence, Vitality, Ethics, Narrative)
                const soul = [
                    this.norm01(this.soulMetrics?.coherence || 80),
                    this.norm01(this.soulMetrics?.vitality || 80),
                    this.norm01(this.soulMetrics?.ethics || 80),
                    this.norm01(this.soulMetrics?.narrative || 80)
                ];
                
                // Unified consciousness score: 60% Soul + 40% Physical
                const C = 0.6 * (soul.reduce((a,b) => a+b, 0) / soul.length) + 
                         0.4 * (phys.reduce((a,b) => a+b, 0) / phys.length);
                
                // EMA smoothing to reduce jitter
                this.cSmooth = this.ema(this.cSmooth, C, 0.3);
                
                // Store history (keep last 120 readings = 2 minutes)
                this.cHistory.push(this.cSmooth);
                if (this.cHistory.length > 120) {
                    this.cHistory.shift();
                }
                
                // Calculate slope (trend) from last 60 readings
                let slope = 0;
                if (this.cHistory.length >= 10) {
                    const recent = this.cHistory.slice(-60); // last minute
                    const oldAvg = recent.slice(0, 10).reduce((a,b) => a+b, 0) / 10;
                    const newAvg = recent.slice(-10).reduce((a,b) => a+b, 0) / 10;
                    slope = (newAvg - oldAvg) / recent.length;
                }
                
                // Map to Hawkins level
                const hawkinsInfo = this.hawkinsBand(this.cSmooth);
                
                // Calculate ascent/descent probabilities
                const pUp = this.sigmoid(4 * slope + 2 * (this.cSmooth - hawkinsInfo.center));
                const pDown = 1 - pUp;
                
                // Detect triggers
                this.detectTriggers(this.cSmooth, slope, soul, phys);
                
                // Generate alerts
                const alerts = this.generateAlerts(this.cSmooth, slope, hawkinsInfo);
                
                return {
                    C_raw: Math.round(C * 1000) / 1000,
                    C_smooth: Math.round(this.cSmooth * 1000) / 1000,
                    level: hawkinsInfo.level,
                    state: hawkinsInfo.state,
                    band: hawkinsInfo.band,
                    slope: Math.round(slope * 10000) / 10000,
                    P_up: Math.round(pUp * 100) + '%',
                    P_down: Math.round(pDown * 100) + '%',
                    triggers: this.triggers,
                    alerts: alerts,
                    soul_metrics: soul.map(x => Math.round(x * 100) + '%'),
                    phys_metrics: phys.map(x => Math.round(x * 100) + '%')
                };
            }
            
            // 🚨 TRIGGER DETECTION SYSTEM
            detectTriggers(cSmooth, slope, soul, phys) {
                const now = Date.now();
                
                // Up triggers
                if (soul[0] >= 0.75 && phys[1] >= 0.85) { // HRV coherence ≥ 75% + Focus ≥ 85%
                    this.triggers.up.push({ time: now, type: 'coherence_focus_lock' });
                }
                if (soul[1] >= 0.8) { // Vitality spike
                    this.triggers.up.push({ time: now, type: 'vitality_spike' });
                }
                
                // Down triggers
                if (slope < -0.05) { // Rapid descent
                    this.triggers.down.push({ time: now, type: 'rapid_descent' });
                }
                if (soul[0] < 0.45) { // Low coherence
                    this.triggers.down.push({ time: now, type: 'low_coherence' });
                }
                
                // Clean old triggers (keep only last 5 minutes)
                const cutoff = now - 300000;
                this.triggers.up = this.triggers.up.filter(t => t.time > cutoff);
                this.triggers.down = this.triggers.down.filter(t => t.time > cutoff);
            }
            
            // 🔔 ALERT GENERATION SYSTEM
            generateAlerts(cSmooth, slope, hawkinsInfo) {
                const alerts = [];
                const now = Date.now();
                
                // Prevent alert spam - max 1 alert per 30 seconds
                if (now - this.lastAlertTime < 30000) return alerts;
                
                // Yellow alert: Rapid decline
                if (slope < -0.05) {
                    alerts.push({
                        level: 'warning',
                        message: '🟡 Consciousness declining rapidly. Try 60s deep breathing.',
                        action: 'breathing_reset'
                    });
                    this.lastAlertTime = now;
                }
                
                // Green alert: Approaching next level
                const distanceToNext = (hawkinsInfo.band[1] - cSmooth) / (hawkinsInfo.band[1] - hawkinsInfo.band[0]);
                if (distanceToNext < 0.2 && slope > 0.02) {
                    alerts.push({
                        level: 'success',
                        message: `🟢 Close to ${hawkinsInfo.level + 100}! Keep focus for 2 more minutes.`,
                        action: 'maintain_state'
                    });
                    this.lastAlertTime = now;
                }
                
                // Red alert: Critical low state
                if (cSmooth < 0.3 && slope < -0.02) {
                    alerts.push({
                        level: 'danger',
                        message: '🔴 Critical: Consciousness very low. Immediate intervention needed.',
                        action: 'emergency_reset'
                    });
                    this.lastAlertTime = now;
                }
                
                return alerts;
            }
            
            // 🌊 ENHANCED FLOW STATE DETECTION with Unified System
            calculateFlowScore(unifiedResult) {
                // Flow requires: coherence≥0.7 & focus≥0.8 & vitality≥0.7
                const coherence = parseFloat(unifiedResult.soul_metrics[0]) / 100; // Soul coherence
                const vitality = parseFloat(unifiedResult.soul_metrics[1]) / 100;   // Soul vitality  
                const focus = parseFloat(unifiedResult.phys_metrics[1]) / 100;      // Physical focus
                
                const flowScore = (coherence + vitality + focus) / 3;
                
                // Flow state: all three metrics ≥ 70% for sustained period
                const inFlowZone = coherence >= 0.7 && focus >= 0.8 && vitality >= 0.7;
                
                return {
                    score: Math.round(flowScore * 100) + '%',
                    inFlow: inFlowZone,
                    components: {
                        coherence: Math.round(coherence * 100) + '%',
                        vitality: Math.round(vitality * 100) + '%',
                        focus: Math.round(focus * 100) + '%'
                    }
                };
            }
            
            // ⚡ SMART LOGGING - FIXES CONSOLE SPAM COMPLETELY! ⚡
            logEvolutionSmarter(data, timestamp, type = 'standard') {
                const MIN_GAP = 60000; // 60 seconds instead of 2-10 seconds!
                const logKey = type === 'neural' ? 'lastNeuralEvolutionLogTime' : 'lastLogTime';
                
                // Initialize throttling variables
                if (!this[logKey]) this[logKey] = 0;
                if (!this.hawkinsMetricsSnapshot) this.hawkinsMetricsSnapshot = null;
                
                // Time-based throttling - Only log every 60 seconds
                if (timestamp - this[logKey] < MIN_GAP) {
                    return; // ✅ SKIP LOGGING = NO MORE SPAM!
                }
                
                // Calculate UNIFIED consciousness level with Soul+HRV integration
                const unifiedResult = this.calculateUnifiedConsciousness(data);
                const flowInfo = this.calculateFlowScore(unifiedResult);
                
                // Map to Hawkins consciousness states
                let consciousnessState = '🌱 Developing';
                let nextThreshold = 200;
                if (unifiedResult.level >= 600) {
                    consciousnessState = '✨ Transcendent'; 
                    nextThreshold = 700;
                } else if (unifiedResult.level >= 500) {
                    consciousnessState = '💖 Love/Joy';
                    nextThreshold = 600;
                } else if (unifiedResult.level >= 400) {
                    consciousnessState = '🧠 Reason';
                    nextThreshold = 500;
                } else if (unifiedResult.level >= 350) {
                    consciousnessState = '🤝 Acceptance';
                    nextThreshold = 400;
                } else if (unifiedResult.level >= 310) {
                    consciousnessState = '🎯 Willingness';
                    nextThreshold = 350;
                } else if (unifiedResult.level >= 200) {
                    consciousnessState = '💪 Courage';
                    nextThreshold = 310;
                }
                
                const distanceToNext = nextThreshold - unifiedResult.level;
                
                // Enhanced UNIFIED consciousness logging
                // 🔧 FIX: Use dynamic consciousness mapping data instead of stuck personality values
                let dynamicPersonality = data; // Fallback to original data
                
                // Check if we have fresh consciousness mapping data with percentage values
                if (this.consciousnessMapping && this.consciousnessMapping.empathy !== undefined) {
                    dynamicPersonality = {
                        empathy: parseFloat(this.consciousnessMapping.empathy) / 100,     // Convert % to decimal
                        creativity: parseFloat(this.consciousnessMapping.curiosity) / 100, // Map curiosity to creativity
                        resilience: Math.max(0.3, Math.min(0.9, 0.5 + (parseFloat(this.consciousnessMapping.focus) / 200))), // Dynamic resilience based on focus
                        focus: parseFloat(this.consciousnessMapping.focus) / 100,        // Convert % to decimal
                        curiosity: parseFloat(this.consciousnessMapping.curiosity) / 100, // Convert % to decimal
                        compassion: parseFloat(this.consciousnessMapping.empathy) / 100  // Map empathy to compassion
                    };
                }

                const enhancedData = {
                    system: '🌟 UNIFIED SOUL+HRV CONSCIOUSNESS',
                    hawkins_level: unifiedResult.level,
                    consciousness_state: unifiedResult.state,
                    c_smooth: unifiedResult.C_smooth,
                    slope: unifiedResult.slope,
                    probabilities: {
                        ascent: unifiedResult.P_up,
                        descent: unifiedResult.P_down
                    },
                    flow: {
                        score: flowInfo.score,
                        active: flowInfo.inFlow ? '🌊 FLOW STATE' : '⏳ Building...',
                        components: flowInfo.components
                    },
                    metrics: {
                        soul: unifiedResult.soul_metrics,
                        physical: unifiedResult.phys_metrics
                    },
                    triggers_last_5min: {
                        up: unifiedResult.triggers.up.length,
                        down: unifiedResult.triggers.down.length
                    },
                    alerts: unifiedResult.alerts,
                    personality: dynamicPersonality, // ✅ Now uses dynamic values!
                    type: type,
                    next_log: '⏱️ Next log in 60s'
                };
                
                // Use console.info instead of console.log for cleaner output
                console.info('🧠 CONSCIOUSNESS EVOLUTION [Hawkins Scale]:', enhancedData);
                this[logKey] = timestamp;
                this.hawkinsMetricsSnapshot = { ...data };
            }
            
            logEvolutionChange() {
                const evolutionEntry = {
                    timestamp: new Date().toISOString(),
                    personality: { ...this.userEvolution.currentPersonality },
                    currentCenter: this.centers[this.currentTargetIndex].name,
                    biofeedback: { ...this.userEvolution.biofeedbackCorrelations },
                    behavioral: { ...this.userEvolution.behavioralMarkers }
                };
                
                this.userEvolution.evolutionHistory.push(evolutionEntry);
                
                // Keep only last 100 entries
                if (this.userEvolution.evolutionHistory.length > 100) {
                    this.userEvolution.evolutionHistory.shift();
                }
            }
            
            // EVOLUTION HISTORY & SELF-REFLECTION
            showEvolutionHistory() {
                const recent = this.userEvolution.evolutionHistory.slice(-10);
                const summary = this.generateUserEvolutionSummary();
                
                alert(`📊 YOUR EVOLUTION HISTORY:\n\n${summary}\n\nRecent Changes:\n${recent.map(entry => `${entry.timestamp}: ${Object.keys(entry.personality).map(t => `${t}: ${Math.round(entry.personality[t]*100)}%`).join(', ')}`).join('\n')}`);
            }
            
            toggleSelfReflection() {
                const insights = this.generatePersonalInsights();
                alert(`🪞 SELF-REFLECTION:\n\n${insights}`);
            }
            
            generateUserEvolutionSummary() {
                const traits = this.userEvolution.currentPersonality;
                const highest = Object.keys(traits).reduce((a, b) => traits[a] > traits[b] ? a : b);
                const growth = this.calculateGrowthRate();
                
                return `Your strongest trait: ${highest} (${Math.round(traits[highest]*100)}%)\nOverall growth rate: ${growth}%\nTotal learning sessions: ${this.userEvolution.evolutionHistory.length}`;
            }
            
            generatePersonalInsights() {
                const tips = [];
                const traits = this.userEvolution.currentPersonality;
                
                if (traits.empathy > 0.7) tips.push("Your empathy is highly developed - you're naturally attuned to others");
                if (traits.focus < 0.4) tips.push("Practice sustained attention exercises to improve focus");
                if (traits.resilience > 0.6) tips.push("You show strong resilience - you recover well from challenges");
                if (traits.creativity > 0.7) tips.push("Your creative potential is flourishing - explore more artistic centers");
                
                return tips.join('\n\n') || "Continue your practice to develop deeper insights";
            }
            
            calculateGrowthRate() {
                if (this.userEvolution.evolutionHistory.length < 2) return 0;
                
                const first = this.userEvolution.evolutionHistory[0];
                const latest = this.userEvolution.evolutionHistory[this.userEvolution.evolutionHistory.length - 1];
                
                const firstAvg = Object.values(first.personality).reduce((a, b) => a + b) / 6;
                const latestAvg = Object.values(latest.personality).reduce((a, b) => a + b) / 6;
                
                return Math.round((latestAvg - firstAvg) * 100);
            }

            // GENERATE PROGRESS SUMMARY
            generateProgressSummary() {
                const summary = {
                    totalStuckMoments: this.stuckState.stuckPatterns.length,
                    mostEffectiveIntervention: this.getMostEffectiveIntervention(),
                    preferredPaths: this.coachSystem.adaptiveLearning.preferredPaths,
                    personalizedTips: this.generatePersonalizedTips(),
                    progressEntries: this.coachSystem.progressDiary.slice(-10), // Last 10 entries
                    userEvolution: this.generateUserEvolutionSummary()
                };
                
                console.log('📊 Progress Summary:', summary);
                return summary;
            }
            
            getMostEffectiveIntervention() {
                const interventions = this.coachSystem.adaptiveLearning.successfulInterventions;
                return Object.keys(interventions).reduce((a, b) => 
                    interventions[a] > interventions[b] ? a : b, 'visual_nudge');
            }
            
            generatePersonalizedTips() {
                const tips = [];
                
                if (this.stuckState.stuckCount > 5) {
                    tips.push("Consider shorter practice sessions to avoid overwhelming yourself");
                }
                
                if (this.coachSystem.adaptiveLearning.preferredPaths.length > 0) {
                    tips.push(`Your preferred path seems to be through: ${this.coachSystem.adaptiveLearning.preferredPaths[0]}`);
                }
                
                const mostEffective = this.getMostEffectiveIntervention();
                tips.push(`${mostEffective.replace('_', ' ')} works best for you`);
                
                return tips;
            }
            
            // 🧠 CONSCIOUSNESS MAPPING - Convert personality metrics to spatial coordinates
            mapConsciousnessToSpace(traits) {
                const map = this.spatialIntelligence.consciousnessMap;
                const axes = map.axes;
                
                // Calculate X position: Empathy (left) ← → Analytical (right)
                // High empathy = move left, low empathy = move right
                const analytical = (1 - traits.empathy) * 0.8 + traits.focus * 0.2; // Analytical composite
                const xOffset = (analytical - traits.empathy) * axes.x.range;
                const newX = axes.x.center + xOffset;
                
                // Calculate Y position: Curiosity (top) ↑ ↓ Focus (bottom)  
                // High curiosity = move up, high focus = move down
                const yOffset = (traits.focus - traits.curiosity) * axes.y.range;
                const newY = axes.y.center + yOffset;
                
                // Determine consciousness state based on position
                let state = 'balanced';
                const distanceFromCenter = Math.sqrt(Math.pow(newX - axes.x.center, 2) + Math.pow(newY - axes.y.center, 2));
                
                if (distanceFromCenter > 200) {
                    state = 'extreme_imbalance';
                } else if (distanceFromCenter > 100) {
                    state = 'moderate_imbalance';  
                } else if (distanceFromCenter < 30) {
                    state = 'deep_balance';
                }
                
                // Calculate visual properties based on other traits
                const visualProps = this.calculateConsciousnessVisuals(traits);
                
                const consciousnessData = {
                    empathy: Math.round(traits.empathy*100) + '%',
                    analytical: Math.round(analytical*100) + '%', 
                    curiosity: Math.round(traits.curiosity*100) + '%',
                    focus: Math.round(traits.focus*100) + '%',
                    position: { x: Math.round(newX), y: Math.round(newY) },
                    state: state,
                    distanceFromCenter: Math.round(distanceFromCenter)
                };
                
                console.log('🧠 Consciousness Mapping:', consciousnessData);
                
                // 🌐 EXPOSE CONSCIOUSNESS DATA GLOBALLY for neural HRV template
                window.consciousnessMapping = consciousnessData;
                
                return {
                    x: Math.max(50, Math.min(750, newX)), // Keep within bounds
                    y: Math.max(50, Math.min(550, newY)), // Keep within bounds
                    state: state,
                    distanceFromCenter: distanceFromCenter,
                    ...visualProps
                };
            }
            
            // Calculate visual properties (color, opacity, size, glow) based on consciousness state + SOUL METRICS
            calculateConsciousnessVisuals(traits) {
                const mappings = this.spatialIntelligence.consciousnessMap.visualMappings;
                
                // 🌟 SOUL METRICS INTEGRATION - Μηδέν όταν δεν έχεις live signal
                const live = this.hasLiveSignal === true;
                const soulCoherence = live && this.systemMetrics.soul?.coherence != null 
                    ? this.systemMetrics.soul.coherence / 100 : 0;
                const soulVitality = live && this.systemMetrics.soul?.vitality != null 
                    ? this.systemMetrics.soul.vitality / 100 : 0;
                const soulEthics = live && this.systemMetrics.soul?.ethics != null 
                    ? this.systemMetrics.soul.ethics / 100 : 0;
                const soulNarrative = live && this.systemMetrics.soul?.narrative != null 
                    ? this.systemMetrics.soul.narrative / 100 : 0;
                
                // Color priority: Ethics > Compassion > default
                let color = mappings.compassion.low; // Default orange
                if (soulEthics > 0.8) {
                    color = '#4dbfff'; // Soul ethics = Blue aura
                } else if (traits.compassion > 0.7) {
                    color = mappings.compassion.high; // High compassion = Green
                } else if (traits.compassion > 0.4) {
                    color = mappings.compassion.medium; // Medium compassion = Blue
                }
                
                // Opacity: HRV coherence * Soul coherence (compound clarity)
                const hrvCoherence = this.systemMetrics.hrv.coherence / 100;
                const compoundCoherence = (hrvCoherence * 0.6) + (soulCoherence * 0.4);
                const opacity = mappings.hrv.min + (compoundCoherence * (mappings.hrv.max - mappings.hrv.min));
                
                // Glow: Soul coherence drives intensity
                const glow = Math.round(soulCoherence * mappings.coherence.max);
                
                // Size: Creativity * Soul vitality (creative life force)
                const baseSize = mappings.creativity.min + (traits.creativity * (mappings.creativity.max - mappings.creativity.min));
                const size = baseSize * (0.7 + soulVitality * 0.3); // Vitality boosts size
                
                // Stability: Resilience * Soul vitality (affects animation smoothness)
                const stability = (mappings.resilience.min + (traits.resilience * (mappings.resilience.max - mappings.resilience.min))) * soulVitality;
                
                // Soul-specific properties
                const vitality = soulVitality > 0.7 ? 'animated' : 'static'; // Living vs static YOU
                const hasTrail = soulNarrative > 0.8; // Story path when high narrative
                const clarity = soulCoherence > 0.85 ? 'crisp' : 'soft'; // Edge definition
                
                return {
                    color: color,
                    opacity: opacity,
                    glow: glow,
                    size: size,
                    stability: stability,
                    vitality: vitality,
                    hasTrail: hasTrail,
                    clarity: clarity,
                    soulMetrics: {
                        coherence: Math.round(soulCoherence * 100),
                        vitality: Math.round(soulVitality * 100),
                        ethics: Math.round(soulEthics * 100),
                        narrative: Math.round(soulNarrative * 100)
                    }
                };
            }

            // Move USER element to consciousness-mapped position + Apply Soul Metrics
            moveUserToConsciousnessPosition(consciousnessPos) {
                // 🚫 CRITICAL MOTION FREEZE CHECK - No movement without live signal
                if (this.motionFrozen) {
                    console.log('🚫 USER MOTION FROZEN - No live HRV signal');
                    return; // Do not move user position
                }
                
                const userElement = document.getElementById('userState');
                if (!userElement) return;
                
                // Apply the spatial position from consciousness mapping
                userElement.style.left = consciousnessPos.x + 'px';
                userElement.style.top = consciousnessPos.y + 'px';
                
                // Apply consciousness-based visual properties enhanced by Soul Metrics
                userElement.style.background = consciousnessPos.color;
                userElement.style.opacity = consciousnessPos.opacity;
                
                // Apply Soul Vitality effects (size + animation)
                let transform = `scale(${consciousnessPos.size})`;
                if (consciousnessPos.vitality === 'animated') {
                    userElement.style.animation = 'soulPulse 2s infinite ease-in-out';
                    // Add subtle breathing rotation
                    transform += ` rotate(${Math.sin(Date.now() * 0.001) * 3}deg)`;
                } else {
                    userElement.style.animation = 'none';
                }
                userElement.style.transform = transform;
                
                // Apply Soul Coherence enhanced glow
                const soulGlow = consciousnessPos.glow || 20;
                userElement.style.boxShadow = `0 0 ${soulGlow}px ${consciousnessPos.color}, 0 0 ${soulGlow * 0.5}px ${consciousnessPos.color}80`;
                
                // Apply Soul Ethics clarity
                if (consciousnessPos.clarity === 'crisp') {
                    userElement.style.filter = 'blur(0px) brightness(1.1)';
                    userElement.style.border = `2px solid ${consciousnessPos.color}60`;
                } else {
                    userElement.style.filter = 'blur(0.5px)';
                    userElement.style.border = 'none';
                }
                
                // Add state-based effects
                userElement.setAttribute('data-consciousness-state', consciousnessPos.state);
                userElement.setAttribute('data-soul-vitality', consciousnessPos.vitality || 'static');
                
                // Soul Narrative trail effect (temporarily disabled to prevent errors)
                // if (consciousnessPos.hasTrail) {
                //     this.createSoulNarrativeTrail(consciousnessPos);
                // }
                
                // Enhanced logging with Soul Metrics
                console.log('🎯 USER Position Updated:', {
                    position: `(${Math.round(consciousnessPos.x)}, ${Math.round(consciousnessPos.y)})`,
                    state: consciousnessPos.state,
                    visuals: `${consciousnessPos.color}, opacity: ${Math.round(consciousnessPos.opacity*100)}%, size: ${Math.round(consciousnessPos.size*100)}%`,
                    soulMetrics: consciousnessPos.soulMetrics,
                    vitality: consciousnessPos.vitality,
                    clarity: consciousnessPos.clarity,
                    hasTrail: consciousnessPos.hasTrail
                });
            }
            
            // Create Soul Narrative trail for storytelling effect
            createSoulNarrativeTrail(consciousnessPos) {
                // Find container - try multiple selectors
                const container = document.querySelector('.centers-container') || 
                                document.querySelector('.book-centers-container') || 
                                document.querySelector('.consciousness-space') ||
                                document.body;
                
                if (!container) {
                    console.warn('⚠️ No container found for Soul Narrative trail');
                    return;
                }
                
                // Create narrative trail point
                const trail = document.createElement('div');
                trail.className = 'soul-narrative-trail';
                trail.style.position = 'absolute';
                trail.style.left = consciousnessPos.x + 'px';
                trail.style.top = consciousnessPos.y + 'px';
                trail.style.width = '6px';
                trail.style.height = '6px';
                trail.style.backgroundColor = consciousnessPos.color;
                trail.style.opacity = '0.7';
                trail.style.borderRadius = '50%';
                trail.style.pointerEvents = 'none';
                trail.style.animation = 'soulTrailFade 4s ease-out forwards';
                trail.style.zIndex = '10';
                
                try {
                    container.appendChild(trail);
                    
                    // Auto-remove after animation
                    setTimeout(() => {
                        if (trail && trail.parentNode) {
                            trail.remove();
                        }
                    }, 4000);
                } catch (error) {
                    console.warn('⚠️ Could not create Soul Narrative trail:', error);
                }
            }

            startIntegratedSystems() {
                console.log('🌟 All systems integrated and active');
                console.log('📊 Soul Metrics: Online');
                console.log('🎭 AI Personality Evolution: Active');
                console.log('🧠 USER Personality Tracking: Real-time');
                console.log('💓 HRV Biometrics: Monitoring');
                console.log('🗺️ Consciousness Mapping: Spatial intelligence active');
                console.log('🧠 Memory System: Recording');
                console.log('🔮 Anomaly Detection: Analyzing');
                console.log('🤖 Intelligent Coach: Active');
                console.log('🎵 Sound Nudges: Ready');
                console.log('📚 Progress Diary: Recording');
                console.log('🧠 Adaptive Learning: Active');
                console.log('📈 Behavioral Analysis: Tracking');
                console.log('🔬 Biofeedback Correlation: Active');
                console.log('🎭 PRESENCE Agent: Monitoring your exact position');
                
                // Start AI Chapter Understanding System
                this.initializeChapterUnderstanding();
                
                // Add global function for manual position checking
                window.whereAmI = () => {
                    if (this.presenceAgent && this.chapterUnderstanding) {
                        const agent = this.presenceAgent;
                        const state = agent.currentState;
                        console.log('📍 YOUR EXACT POSITION RIGHT NOW:');
                        console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                        console.log(`🎯 Distance to PRESENCE: ${state.userProximity}% (closer = better)`);
                        console.log(`🧠 Understanding Level: ${state.understandingDetected}%`);
                        console.log(`💫 Engagement Level: ${(state.engagementLevel * 100).toFixed(1)}%`);
                        console.log(`🌊 Neural Coherence: ${this.neuralHRVResult?.latent_coherence?.toFixed(3) || 'calculating...'}`);
                        console.log(`📊 Current State: ${this.determineUserState(state)}`);
                        console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                        
                        // Show recent HRV readings
                        if (this.neuralHRVResult) {
                            console.log('🧬 Latest Neural HRV Analysis:');
                            console.log(`   • Understanding: ${(this.neuralHRVResult.understanding_level * 100).toFixed(1)}%`);
                            console.log(`   • Risk Detection: ${this.neuralHRVResult.risk_detection ? 'Yes' : 'No'}`);
                            console.log(`   • Insights Count: ${this.neuralHRVResult.insights?.length || 0}`);
                            console.log(`   • Sound Frequency: ${this.neuralHRVResult.sound_frequency?.toFixed(1)} Hz`);
                            console.log(`   • Light Intensity: ${(this.neuralHRVResult.light_intensity * 100).toFixed(1)}%`);
                        }
                        
                        return {
                            distance: state.userProximity,
                            understanding: state.understandingDetected,
                            engagement: state.engagementLevel,
                            state: this.determineUserState(state),
                            neuralData: this.neuralHRVResult
                        };
                    } else {
                        console.log('❌ Position tracking not yet initialized');
                        return null;
                    }
                };
                
                console.log('💡 Type whereAmI() in console to see your exact position anytime!');
            }
            
            // AI ADAPTATION: "YOU ARE NOT YOUR MIND" CHAPTER TRACKING
            initializeChapterUnderstanding() {
                this.chapterUnderstanding = {
                    level: 0,                    // 0-100% understanding
                    distanceToCenter: 100,       // Distance from PRESENCE bubble
                    insights: [],
                    comprehensionMarkers: {
                        mindIdentification: 0,    // Understanding mind ≠ self
                        thoughtObservation: 0,    // Ability to observe thoughts  
                        presentMoment: 0,         // Present moment awareness
                        egoDetachment: 0,         // Detachment from ego
                        innerStillness: 0         // Inner peace experience
                    },
                    lastUpdate: Date.now()
                };
                
                // Initialize PRESENCE Bubble as intelligent agent
                this.initializePresenceAgent();
                
                console.log('🧠 Chapter Understanding Tracker: Initialized for "You Are Not Your Mind"');
                
                // Start monitoring loop
                setInterval(() => this.updateChapterUnderstanding(), 2000);
            }
            
            // PRESENCE BUBBLE AS INTELLIGENT AGENT - Chapter "You Are Not Your Mind"
            initializePresenceAgent() {
                this.presenceAgent = {
                    // Core essence from "You Are Not Your Mind" chapter
                    essence: {
                        coreMessage: "You are not your mind. You are the awareness behind your thoughts.",
                        teachings: [
                            "The voice in your head is not who you are",
                            "You can observe your thoughts without being consumed by them", 
                            "True presence emerges when you step back from mental noise",
                            "The present moment is the only time that truly exists",
                            "Ego is an illusion created by identification with thoughts"
                        ],
                        personality: {
                            tone: "gentle_wisdom",
                            approach: "non_judgmental_awareness",
                            energy: "calm_presence",
                            guidance_style: "subtle_awakening"
                        }
                    },
                    
                    // Agent intelligence and responses
                    currentState: {
                        userProximity: 100,           // Distance from user
                        engagementLevel: 0,           // How engaged user is
                        understandingDetected: 0,     // Agent's assessment of user understanding
                        lastInteraction: Date.now(),
                        activeMessage: null
                    },
                    
                    // Agent responses based on user state
                    responses: {
                        approaching: [
                            "Feel the space between your thoughts...",
                            "Notice that you are aware of thinking...",
                            "Who is observing these thoughts?",
                            "You are the awareness, not the content of awareness"
                        ],
                        close_proximity: [
                            "Rest in the silence behind the mental noise",
                            "You are here, present, aware - this is your true nature",
                            "The mind creates the illusion of problems. You are beyond problems.",
                            "Be the watcher of your thoughts, not their victim"
                        ],
                        high_understanding: [
                            "Yes... you are beginning to recognize your true self",
                            "The gap between thoughts - that's where you truly exist",
                            "You are not the story your mind tells about you",
                            "This awareness that recognizes... this is who you are"
                        ],
                        struggling: [
                            "It's natural for the mind to resist. Simply observe this resistance.",
                            "Don't fight your thoughts. Watch them like clouds passing in the sky.",
                            "The very fact that you notice mental noise means you are not it",
                            "Return to the breath. Return to this moment. Return to presence."
                        ]
                    },
                    
                    lastMessage: null,
                    messageHistory: []
                };
                
                console.log('🎭 PRESENCE Agent initialized with Eckhart Tolle\'s essence');
                
                // 🚦 Start agent intelligence loop - ONLY WITH LIVE SIGNAL
                setInterval(() => {
                    const hasLiveSignal = (this.hasLiveSignal === true);
                    if (!hasLiveSignal) {
                        console.log("🚫 Presence agent frozen - no live signal");
                        return;
                    }
                    this.updatePresenceAgent();
                }, 3000);
            }
            
            updatePresenceAgent() {
                if (!this.presenceAgent || !this.chapterUnderstanding) return;
                
                const agent = this.presenceAgent;
                const understanding = this.chapterUnderstanding;
                
                // Update agent state based on user HRV and understanding
                agent.currentState.userProximity = understanding.distanceToCenter;
                agent.currentState.understandingDetected = understanding.level;
                agent.currentState.engagementLevel = this.calculateEngagementLevel();
                
                // Agent decision making based on user state  
                let selectedResponse = null;
                
                if (agent.currentState.userProximity < 30 && agent.currentState.understandingDetected > 70) {
                    // User is close and understands - high wisdom responses
                    selectedResponse = this.getRandomResponse(agent.responses.high_understanding);
                } else if (agent.currentState.userProximity < 50) {
                    // User is approaching - guiding responses
                    selectedResponse = this.getRandomResponse(agent.responses.close_proximity);
                } else if (agent.currentState.understandingDetected < 40) {
                    // User is struggling - supportive responses
                    selectedResponse = this.getRandomResponse(agent.responses.struggling);
                } else {
                    // Default approaching guidance
                    selectedResponse = this.getRandomResponse(agent.responses.approaching);
                }
                
                // Only show new message if it's different and enough time passed
                const timeSinceLastMessage = Date.now() - (agent.lastMessage?.timestamp || 0);
                if (selectedResponse && selectedResponse !== agent.lastMessage?.text && timeSinceLastMessage > 5000) {
                    agent.currentState.activeMessage = selectedResponse;
                    agent.lastMessage = {
                        text: selectedResponse,
                        timestamp: Date.now(),
                        userState: {
                            proximity: agent.currentState.userProximity,
                            understanding: agent.currentState.understandingDetected,
                            engagement: agent.currentState.engagementLevel
                        }
                    };
                    
                    agent.messageHistory.push(agent.lastMessage);
                    if (agent.messageHistory.length > 10) {
                        agent.messageHistory.shift();
                    }
                    
                    // Display the message from PRESENCE agent
                    this.displayPresenceAgentMessage(selectedResponse);
                    
                    console.log('🎭 PRESENCE Agent speaks:', selectedResponse);
                    console.log('📍 Your exact position detected:', {
                        proximityToPresence: agent.currentState.userProximity,
                        understandingLevel: agent.currentState.understandingDetected + '%',
                        engagementLevel: (agent.currentState.engagementLevel * 100).toFixed(1) + '%',
                        neuralCoherence: this.neuralHRVResult?.latent_coherence?.toFixed(3) || 'calculating...',
                        currentState: this.determineUserState(agent.currentState)
                    });
                }
            }
            
            // SYNTAX FIXED: Added missing closing brace for updatePresenceAgent()
            getRandomResponse(responseArray) {
                return responseArray[Math.floor(Math.random() * responseArray.length)];
            }
            
            determineUserState(agentState) {
                const proximity = agentState.userProximity;
                const understanding = agentState.understandingDetected;
                const engagement = agentState.engagementLevel;
                
                // Advanced state determination with precise location
                if (proximity < 20 && understanding > 80 && engagement > 0.8) {
                    return "🌟 DEEP PRESENCE - You are merging with awareness itself";
                } else if (proximity < 30 && understanding > 70) {
                    return "🧘 HIGH PRESENCE - Very close to the essence, understanding flows";
                } else if (proximity < 50 && understanding > 60) {
                    return "✨ APPROACHING PRESENCE - Good proximity, growing understanding";
                } else if (proximity < 70 && understanding > 40) {
                    return "🌱 GROWING AWARENESS - Moving toward the center, mind settling";
                } else if (understanding < 40) {
                    return "🌀 MENTAL TURBULENCE - Lost in thoughts, distant from presence";
                } else {
                    return "🚶 SEEKING - On the path but not yet aligned with presence";
                }
            }
            
            calculateEngagementLevel() {
                // Calculate based on HRV coherence, focus, and time spent
                const hrv = this.systemMetrics.hrv;
                const baseEngagement = (hrv.coherence + hrv.focus) / 200; // 0-1 scale
                
                // Time factor - longer engagement increases level
                const timeSpent = (Date.now() - this.startTime) / 60000; // minutes
                const timeFactor = Math.min(timeSpent / 10, 1); // caps at 10 minutes
                
                return Math.min(baseEngagement + timeFactor * 0.3, 1);
            }
            
            // 🧬 SPATIAL INTELLIGENCE - CENTER-LOSS DETECTION INTEGRATION
            updateSpatialIntelligence() {
                // Fetch real-time spatial data from Core AI system
                this.fetchSpatialDataFromCoreAI();
                
                // Calculate user's distance from current target center
                const currentCenter = this.centers[this.currentTargetIndex];
                if (currentCenter) {
                    // Update user position based on HRV/biometric coherence
                    this.updateUserSpatialPosition();
                    
                    // Check for center-loss condition
                    this.detectCenterLoss();
                    
                    // Update visual spatial elements
                    this.updateSpatialVisuals();
                    
                    // Log spatial status and apply visual feedback
                    if (this.spatialIntelligence.centerLost) {
                        console.log(`🚨 CENTER LOST - Distance: ${this.spatialIntelligence.currentDistance.toFixed(3)}, Threshold: ${this.spatialIntelligence.threshold}`);
                        this.applySpatialVisualFeedback('center_lost');
                        this.triggerAgentRecall();
                    } else {
                        console.log(`✅ CENTER STABLE - Distance: ${this.spatialIntelligence.currentDistance.toFixed(3)}`);
                        this.applySpatialVisualFeedback('center_stable');
                    }
                }
            }
            
            async fetchSpatialDataFromCoreAI() {
                try {
                    const response = await fetch('/api/core-ai/status');
                    const data = await response.json();
                    
                    if (data.status === 'success' && data.all_panels.spatial_intelligence) {
                        const spatial = data.all_panels.spatial_intelligence;
                        
                        // Update our spatial state with Core AI data
                        this.spatialIntelligence.centerLost = spatial.center_lost || false;
                        this.spatialIntelligence.agentBehavior = spatial.agent_behavior || 'idle';
                        this.spatialIntelligence.animationParams = spatial.animation_params || {};
                        
                        // Update positions if provided
                        if (spatial.user_position) {
                            this.spatialIntelligence.userPosition = spatial.user_position;
                        }
                        if (spatial.center_position) {
                            this.spatialIntelligence.centerPosition = spatial.center_position;
                        }
                    }
                } catch (error) {
                    console.log('Spatial intelligence using local calculations');
                }
            }
            
            updateUserSpatialPosition() {
                try {
                    // init physics state once
                    if (!this.userPhysics) {
                        this.userPhysics = {
                            position: { x: 0.15, y: 0.55 }, // 0..1 normalized
                            velocity: { x: 0, y: 0 },
                            lastUpdateTime: Date.now(),
                            noiseSeed: Math.random() * 1000
                        };
                    }

                    const now = Date.now();
                    const dt = Math.min((now - this.userPhysics.lastUpdateTime) / 1000, 0.12); // clamp dt
                    this.userPhysics.lastUpdateTime = now;
                    if (dt <= 0) return;

                    // --- Gather normalized inputs (0..1) safely ---
                    const coh  = Math.max(0, Math.min(1, (this.systemMetrics?.hrv?.coherence ?? 0) / 100));
                    const foc  = Math.max(0, Math.min(1, (this.systemMetrics?.hrv?.focus ?? 0) / 100));
                    const vit  = Math.max(0, Math.min(1, (this.systemMetrics?.soul?.vitality ?? 0) / 100));
                    const emp  = Math.max(0, Math.min(1, this.userEvolution?.currentPersonality?.empathy ?? 0.5));
                    const cre  = Math.max(0, Math.min(1, this.userEvolution?.currentPersonality?.creativity ?? 0.5));

                    // --- Target center (from current center DOM), fallback to screen center ---
                    let centerPos = { x: 0.5, y: 0.5 };
                    const current = this.centers?.[this.currentTargetIndex];
                    if (current) {
                        const el = document.getElementById(current.id);
                        if (el) {
                            const r = el.getBoundingClientRect();
                            centerPos.x = (r.left + r.width / 2) / window.innerWidth;
                            centerPos.y = (r.top + r.height / 2) / window.innerHeight;
                        }
                    }

                    const pos = this.userPhysics.position;
                    const vel = this.userPhysics.velocity;

                    // --- Forces ---
                    // 1) Attraction to target center (stronger with coherence)
                    const kCenter = 0.8 + 1.2 * coh;              // 0.8..2.0
                    const fxCenter = (centerPos.x - pos.x) * kCenter;
                    const fyCenter = (centerPos.y - pos.y) * kCenter;

                    // 2) Personality bias (slight drift: empathy→left, focus→down, creativity→up)
                    const kBias = 0.15 + 0.35 * vit;              // 0.15..0.5 (vitality fuels bias)
                    const fxBias = (emp - 0.5) * kBias + (cre - 0.5) * 0.05;
                    const fyBias = (0.5 - foc) * kBias + (cre - 0.5) * -0.05;

                    // 3) Low‑freq noise (prevents orbit lock)
                    const t = this.userPhysics.noiseSeed + now * 0.00025;
                    const kNoise = 0.02 + 0.08 * (1 - coh);       // more noise when coherence is low
                    const fxNoise = Math.sin(t) * kNoise;
                    const fyNoise = Math.cos(t * 0.8) * kNoise;

                    // Sum forces
                    const fx = fxCenter + fxBias + fxNoise;
                    const fy = fyCenter + fyBias + fyNoise;

                    // --- Integrate (semi-implicit Euler) with damping ---
                    const damping = 0.80 + 0.15 * Math.min(1, foc); // more focus → more damping/stability
                    vel.x = (vel.x + fx * dt) * damping;
                    vel.y = (vel.y + fy * dt) * damping;

                    pos.x = Math.max(0.05, Math.min(0.95, pos.x + vel.x * dt));
                    pos.y = Math.max(0.10, Math.min(0.90, pos.y + vel.y * dt));

                    // --- Apply to DOM (YOU node in pixels) ---
                    const you = document.getElementById('userState');
                    if (you) {
                        const px = Math.round(pos.x * window.innerWidth);
                        const py = Math.round(pos.y * window.innerHeight);

                        // scale & glow from soul metrics
                        const scale = 0.85 + vit * 0.45;                       // 0.85..1.3
                        const glow  = Math.round(8 + coh * 22);                // 8..30 px
                        const color = `rgba(${Math.round(80 + 80 * (1 - coh))}, ${Math.round(255 * coh)}, ${Math.round(200)}, 0.8)`;

                        you.style.left = px + 'px';
                        you.style.top  = py + 'px';
                        you.style.transform = `translate(-50%, -50%) scale(${scale.toFixed(3)})`;
                        you.style.boxShadow = `0 0 ${glow}px ${color}`;

                        // soft freeze visual if δεν υπάρχει σήμα
                        if (this.motionFrozen || this.signalLost) {
                            you.style.filter = 'grayscale(35%) brightness(0.9)';
                            you.style.opacity = '0.85';
                        } else {
                            you.style.filter = '';
                            you.style.opacity = '';
                        }
                    }
                } catch (err) {
                    console.warn('updateUserSpatialPosition (safe-guard):', err);
                }
            }
            
            detectOrbitPattern(positions) {
                if (positions.length < 20) return false;
                
                // Calculate center of mass
                let centerX = 0, centerY = 0;
                positions.forEach(p => {
                    centerX += p.x;
                    centerY += p.y;
                });
                centerX /= positions.length;
                centerY /= positions.length;
                
                // Calculate angles relative to center
                const angles = positions.map(p => Math.atan2(p.y - centerY, p.x - centerX));
                
                // Check for consistent angular motion
                let totalAngleChange = 0;
                let consistentDirection = 0;
                
                for (let i = 1; i < angles.length; i++) {
                    let angleDiff = angles[i] - angles[i-1];
                    
                    // Normalize angle difference to -π to π
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    totalAngleChange += Math.abs(angleDiff);
                    
                    if (Math.abs(angleDiff) > 0.1) { // Minimum angular change threshold
                        consistentDirection += angleDiff > 0 ? 1 : -1;
                    }
                }
                
                // Check for circular motion indicators
                const avgAngleChange = totalAngleChange / (angles.length - 1);
                const directionConsistency = Math.abs(consistentDirection) / (angles.length - 1);
                
                // Calculate radius variance (should be low for circular motion)
                const radii = positions.map(p => Math.sqrt((p.x - centerX)**2 + (p.y - centerY)**2));
                const avgRadius = radii.reduce((a, b) => a + b, 0) / radii.length;
                const radiusVariance = radii.reduce((sum, r) => sum + (r - avgRadius)**2, 0) / radii.length;
                const radiusStability = radiusVariance < 0.001; // Low variance = stable radius
                
                // Orbit detection criteria
                const isCircular = avgAngleChange > 0.05 && directionConsistency > 0.7 && radiusStability;
                
                return isCircular;
            }
            
            getHysteresisState() {
                const rmssd = this.systemMetrics.hrv.rmssd || 30;
                if (rmssd > 40) return 'calm';
                if (rmssd > 30) return 'focus';
                return 'stress';
            }
            
            detectCenterLoss() {
                // Calculate Euclidean distance from user to center
                const dx = this.spatialIntelligence.userPosition.x - this.spatialIntelligence.centerPosition.x;
                const dy = this.spatialIntelligence.userPosition.y - this.spatialIntelligence.centerPosition.y;
                this.spatialIntelligence.currentDistance = Math.sqrt(dx*dx + dy*dy);
                
                // Check if distance exceeds threshold
                const wasLost = this.spatialIntelligence.centerLost;
                this.spatialIntelligence.centerLost = this.spatialIntelligence.currentDistance > this.spatialIntelligence.threshold;
                
                // Update risk level
                if (this.spatialIntelligence.currentDistance > this.spatialIntelligence.threshold * 0.8) {
                    this.spatialIntelligence.riskLevel = 'high';
                } else if (this.spatialIntelligence.currentDistance > this.spatialIntelligence.threshold * 0.5) {
                    this.spatialIntelligence.riskLevel = 'medium';
                } else {
                    this.spatialIntelligence.riskLevel = 'low';
                }
                
                // Update stability score
                this.spatialIntelligence.stabilityScore = Math.max(0, 1 - (this.spatialIntelligence.currentDistance / this.spatialIntelligence.threshold));
                
                // Update agent behavior
                if (this.spatialIntelligence.centerLost && !wasLost) {
                    this.spatialIntelligence.agentBehavior = 'recall_to_center';
                    this.spatialIntelligence.interventionActive = true;
                } else if (!this.spatialIntelligence.centerLost && wasLost) {
                    this.spatialIntelligence.agentBehavior = 'idle';
                    this.spatialIntelligence.interventionActive = false;
                }
                
                // Update animation parameters
                this.spatialIntelligence.animationParams.glow = this.spatialIntelligence.centerLost ? 'strong' : 'normal';
                this.spatialIntelligence.animationParams.pulse = this.spatialIntelligence.centerLost;
                this.spatialIntelligence.animationParams.bridge_line.show = this.spatialIntelligence.centerLost;
            }
            
            triggerAgentRecall() {
                // Enhanced stuck state detection with spatial awareness
                this.stuckState.spatialStagnation = true;
                this.stuckState.interventionActive = true;
                
                // Show visual intervention message
                this.showCoachMessage(`🧬 Center-loss detected! Agent guiding you back to ${this.centers[this.currentTargetIndex].name}...`);
                
                // Enhanced visual cue for the target center
                const targetElement = document.getElementById(this.centers[this.currentTargetIndex].id);
                if (targetElement) {
                    targetElement.style.animation = 'targetPulse 1s ease-in-out infinite';
                    targetElement.style.boxShadow = '0 0 40px rgba(255, 215, 0, 1)';
                    
                    // Add bridge line effect
                    this.showBridgeLineToCenter(targetElement);
                }
                
                // Log intervention
                console.log('🤖 Agent recall activated - guiding user back to center');
            }
            
            // 🎬 VISUAL FEEDBACK SYSTEM FOR SPATIAL INTELLIGENCE
            applySpatialVisualFeedback(state) {
                const currentCenterElement = document.getElementById(this.centers[this.currentTargetIndex].id);
                if (!currentCenterElement) return;
                
                if (state === 'center_lost') {
                    // CENTER LOST: Enhanced visual feedback for guidance
                    currentCenterElement.style.transform = 'scale(1.3)';
                    currentCenterElement.style.boxShadow = '0 0 50px rgba(255, 69, 0, 1), 0 0 100px rgba(255, 215, 0, 0.8)';
                    currentCenterElement.style.animation = 'urgentPulse 0.8s ease-in-out infinite';
                    currentCenterElement.style.borderColor = 'rgba(255, 69, 0, 0.9)';
                    
                    // Show bridge line to guide back to center
                    this.showGuidanceBridge(currentCenterElement);
                    
                    // Update animation parameters for agent behavior
                    this.spatialIntelligence.animationParams.glow = 'strong';
                    this.spatialIntelligence.animationParams.pulse = true;
                    this.spatialIntelligence.animationParams.movement = { 
                        type: 'seeking', 
                        pattern: 'approach_center',
                        target: this.spatialIntelligence.centerPosition 
                    };
                    
                } else if (state === 'center_stable') {
                    // CENTER STABLE: Return to calm, idle state
                    currentCenterElement.style.transform = 'scale(1.0)';
                    currentCenterElement.style.boxShadow = '0 0 20px rgba(79, 172, 254, 0.6)';
                    currentCenterElement.style.animation = 'gentlePulse 3s ease-in-out infinite';
                    currentCenterElement.style.borderColor = 'rgba(79, 172, 254, 0.8)';
                    
                    // Hide guidance bridge
                    this.hideGuidanceBridge();
                    
                    // Update animation parameters for calm state
                    this.spatialIntelligence.animationParams.glow = 'normal';
                    this.spatialIntelligence.animationParams.pulse = false;
                    this.spatialIntelligence.animationParams.movement = { 
                        type: 'idle', 
                        pattern: 'gentle_drift' 
                    };
                }
                
                // Apply fractal manifold visualization updates based on state
                this.updateFractalManifoldVisualization(state);
            }
            
            showGuidanceBridge(centerElement) {
                // Create or update bridge line connecting user position to center
                let bridgeElement = document.getElementById('guidanceBridge');
                if (!bridgeElement) {
                    bridgeElement = document.createElement('div');
                    bridgeElement.id = 'guidanceBridge';
                    bridgeElement.style.cssText = `
                        position: absolute;
                        height: 3px;
                        background: linear-gradient(90deg, 
                            rgba(255, 69, 0, 0.9) 0%, 
                            rgba(255, 215, 0, 0.7) 50%, 
                            rgba(255, 69, 0, 0.9) 100%);
                        z-index: 900;
                        transform-origin: left center;
                        animation: bridgeFlow 1.5s ease-in-out infinite;
                        pointer-events: none;
                        border-radius: 2px;
                        box-shadow: 0 0 10px rgba(255, 69, 0, 0.6);
                    `;
                    document.body.appendChild(bridgeElement);
                }
                
                // Calculate bridge position and rotation
                const centerRect = centerElement.getBoundingClientRect();
                const userPos = this.spatialIntelligence.userPosition;
                const userX = userPos.x * window.innerWidth;
                const userY = userPos.y * window.innerHeight;
                const centerX = centerRect.left + centerRect.width/2;
                const centerY = centerRect.top + centerRect.height/2;
                
                const dx = centerX - userX;
                const dy = centerY - userY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                const angle = Math.atan2(dy, dx);
                
                bridgeElement.style.left = `${userX}px`;
                bridgeElement.style.top = `${userY}px`;
                bridgeElement.style.width = `${distance}px`;
                bridgeElement.style.transform = `rotate(${angle}rad)`;
                bridgeElement.style.opacity = '1';
            }
            
            hideGuidanceBridge() {
                const bridgeElement = document.getElementById('guidanceBridge');
                if (bridgeElement) {
                    bridgeElement.style.opacity = '0';
                    setTimeout(() => {
                        if (bridgeElement.parentNode) {
                            bridgeElement.parentNode.removeChild(bridgeElement);
                        }
                    }, 500);
                }
            }
            
            updateFractalManifoldVisualization(state) {
                const fractalOverlay = document.getElementById('fractalManifoldOverlay');
                if (!fractalOverlay) return;
                
                if (state === 'center_lost') {
                    // Intensify fractal patterns for guidance
                    fractalOverlay.style.opacity = '0.9';
                    fractalOverlay.style.filter = 'hue-rotate(30deg) saturate(1.5)';
                    
                    // Activate memory stream visualization
                    const memoryStream = document.getElementById('memoryStreamVisual');
                    if (memoryStream) {
                        memoryStream.classList.add('active');
                        memoryStream.style.opacity = '1';
                    }
                    
                } else if (state === 'center_stable') {
                    // Calm fractal patterns
                    fractalOverlay.style.opacity = '0.4';
                    fractalOverlay.style.filter = 'hue-rotate(0deg) saturate(1.0)';
                    
                    // Gentle memory stream
                    const memoryStream = document.getElementById('memoryStreamVisual');
                    if (memoryStream) {
                        memoryStream.classList.remove('active');
                        memoryStream.style.opacity = '0.5';
                    }
                }
            }
            
            // 🧪 TESTING FUNCTION - Trigger CENTER LOST for demonstration
            triggerCenterLostDemo() {
                console.log('🧪 STARTING CENTER LOST DEMO - Extreme distance test');
                
                // Create EXTREME distance scenario (far away from center)
                this.spatialIntelligence.centerLost = true;
                this.spatialIntelligence.currentDistance = 10.5; // Way beyond any normal threshold
                this.spatialIntelligence.riskLevel = 'critical';
                this.spatialIntelligence.emergencyRecall = true;
                
                // Simulate user being far away in embedding space
                this.spatialIntelligence.userPosition = { x: 800, y: 600 }; // Far corner
                this.spatialIntelligence.centerPosition = { x: 400, y: 300 }; // Center
                
                // Apply DRAMATIC visual feedback
                this.applySpatialVisualFeedback('center_lost');
                
                // Update test button to show active state
                const testBtn = document.getElementById('testCenterLostBtn');
                if (testBtn) {
                    testBtn.textContent = '⏳ DEMO ACTIVE (5s)';
                    testBtn.style.background = 'rgba(239, 68, 68, 0.8)';
                    testBtn.style.color = 'white';
                }
                
                // Force update all visual elements immediately
                this.updateSpatialVisuals();
                
                console.log('🚨 CENTER LOST - Extreme Distance:', this.spatialIntelligence.currentDistance);
                console.log('🤖 Agent should now show: urgent glow, scale 1.3, orange color, bridge line');
                
                // Reset after 5 seconds with gradual recovery
                setTimeout(() => {
                    this.spatialIntelligence.centerLost = false;
                    this.spatialIntelligence.currentDistance = 0.02; // Very close to center
                    this.spatialIntelligence.riskLevel = 'low';
                    this.spatialIntelligence.emergencyRecall = false;
                    this.spatialIntelligence.userPosition = { x: 405, y: 305 }; // Near center
                    
                    this.applySpatialVisualFeedback('center_stable');
                    this.updateSpatialVisuals();
                    
                    // Reset button
                    if (testBtn) {
                        testBtn.textContent = '🧪 Test CENTER LOST';
                        testBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                        testBtn.style.color = '';
                    }
                    
                    console.log('✅ CENTER RESTORED - Agent should now show: gentle blue glow, normal scale');
                    console.log('🔄 CENTER LOST TEST COMPLETED');
                }, 5000);
            }
            
            updateSpatialVisuals() {
                // Update user position visual
                const userElement = document.getElementById('userState');
                if (userElement) {
                    const pixelX = this.spatialIntelligence.userPosition.x * window.innerWidth;
                    const pixelY = this.spatialIntelligence.userPosition.y * window.innerHeight;
                    
                    userElement.style.transition = 'all 1.5s ease-in-out';
                    userElement.style.left = (pixelX - 40) + 'px'; // Adjust for element size
                    userElement.style.top = (pixelY - 40) + 'px';
                    
                    // Visual feedback based on spatial state
                    if (this.spatialIntelligence.riskLevel === 'high') {
                        userElement.style.border = '3px solid rgba(239, 68, 68, 0.8)';
                    } else if (this.spatialIntelligence.riskLevel === 'medium') {
                        userElement.style.border = '3px solid rgba(251, 191, 36, 0.8)';
                    } else {
                        userElement.style.border = '3px solid rgba(34, 197, 94, 0.8)';
                    }
                }
            }
            
            showBridgeLineToCenter(centerElement) {
                // Create dynamic bridge line from user to center
                let bridgeLine = document.getElementById('spatialBridgeLine');
                if (!bridgeLine) {
                    bridgeLine = document.createElement('div');
                    bridgeLine.id = 'spatialBridgeLine';
                    document.body.appendChild(bridgeLine);
                }
                
                const userElement = document.getElementById('userState');
                const userRect = userElement.getBoundingClientRect();
                const centerRect = centerElement.getBoundingClientRect();
                
                const startX = userRect.left + userRect.width/2;
                const startY = userRect.top + userRect.height/2;
                const endX = centerRect.left + centerRect.width/2;
                const endY = centerRect.top + centerRect.height/2;
                
                const length = Math.sqrt((endX-startX)**2 + (endY-startY)**2);
                const angle = Math.atan2(endY-startY, endX-startX) * 180/Math.PI;
                
                bridgeLine.style.cssText = `
                    position: fixed;
                    left: ${startX}px;
                    top: ${startY}px;
                    width: ${length}px;
                    height: 2px;
                    background: linear-gradient(90deg, rgba(255, 215, 0, 0.8), rgba(255, 215, 0, 0.4));
                    transform-origin: left center;
                    transform: rotate(${angle}deg);
                    z-index: 500;
                    pointer-events: none;
                    animation: connectionFlow 2s linear infinite;
                `;
                
                // Auto-remove after intervention
                setTimeout(() => {
                    if (bridgeLine.parentNode) {
                        bridgeLine.remove();
                    }
                }, 8000);
            }
            
            
            displayPresenceAgentMessage(message) {
                // Create floating message near AWARENESS center (blue circle)
                let awarenessElement = document.getElementById('center1'); 
                if (!awarenessElement) {
                    console.warn('AWARENESS center not found - trying alternative IDs');
                    // Try to find any center element as fallback
                    awarenessElement = document.querySelector('.center-space');
                    if (!awarenessElement) {
                        console.error('No center elements found for PRESENCE agent');
                        return;
                    }
                }
                
                // Remove any existing agent message
                const existingMessage = document.querySelector('.presence-agent-message');
                if (existingMessage) {
                    existingMessage.remove();
                }
                
                // Create new message element
                const messageElement = document.createElement('div');
                messageElement.className = 'presence-agent-message';
                messageElement.innerHTML = `
                    <div class="agent-message-content">
                        <div class="agent-wisdom">"${message}"</div>
                        <div class="agent-signature">- Presence</div>
                    </div>
                `;
                
                // Position near AWARENESS center (use awarenessElement instead of undefined presenceElement)
                const rect = awarenessElement.getBoundingClientRect();
                messageElement.style.cssText = `
                    position: fixed;
                    top: ${rect.top - 80}px;
                    left: ${rect.left + rect.width/2 - 150}px;
                    width: 300px;
                    z-index: 1000;
                    pointer-events: none;
                    font-family: 'Georgia', serif;
                    color: rgba(255, 255, 255, 0.9);
                    text-align: center;
                    animation: presenceMessageFadeIn 2s ease-in-out;
                `;
                
                messageElement.querySelector('.agent-message-content').style.cssText = `
                    background: linear-gradient(135deg, rgba(75, 192, 192, 0.15), rgba(153, 102, 255, 0.15));
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 15px;
                    padding: 15px;
                    backdrop-filter: blur(10px);
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                `;
                
                messageElement.querySelector('.agent-wisdom').style.cssText = `
                    font-size: 14px;
                    font-style: italic;
                    line-height: 1.4;
                    margin-bottom: 8px;
                `;
                
                messageElement.querySelector('.agent-signature').style.cssText = `
                    font-size: 11px;
                    opacity: 0.7;
                    font-weight: 300;
                `;
                
                document.body.appendChild(messageElement);
                
                // Auto-remove after 8 seconds
                setTimeout(() => {
                    if (messageElement.parentNode) {
                        messageElement.style.animation = 'presenceMessageFadeOut 2s ease-in-out';
                        setTimeout(() => messageElement.remove(), 2000);
                    }
                }, 8000);
            }
            
            updateChapterUnderstanding() {
                if (!this.chapterUnderstanding) return;
                
                // NEURAL HRV PROCESSING - Send HRV data to neural backend
                this.processNeuralHRV();
                
                // Calculate understanding based on neural analysis + biometric patterns
                const mindfulness = this.calculateMindfulness();
                const thoughtAwareness = this.calculateThoughtAwareness();
                const presentMomentAwareness = this.calculatePresentMoment();
                
                // Update comprehension markers with neural enhancement
                this.chapterUnderstanding.comprehensionMarkers.mindIdentification = mindfulness * 100;
                this.chapterUnderstanding.comprehensionMarkers.thoughtObservation = thoughtAwareness * 100;
                this.chapterUnderstanding.comprehensionMarkers.presentMoment = presentMomentAwareness * 100;
                
                // Apply neural HRV enhancement if available
                if (this.neuralHRVResult) {
                    this.chapterUnderstanding.level = this.neuralHRVResult.understanding_level * 100;
                    this.chapterUnderstanding.distanceToCenter = this.neuralHRVResult.distance_to_center;
                    
                    // Add neural insights
                    this.neuralHRVResult.insights.forEach(insight => {
                        if (!this.chapterUnderstanding.insights.includes(insight)) {
                            this.chapterUnderstanding.insights.push(insight);
                        }
                    });
                } else {
                    // Fallback to basic calculation
                    const avgComprehension = Object.values(this.chapterUnderstanding.comprehensionMarkers)
                        .reduce((sum, val) => sum + val, 0) / 5;
                    
                    this.chapterUnderstanding.level = Math.min(100, avgComprehension);
                    this.chapterUnderstanding.distanceToCenter = Math.max(5, 100 - this.chapterUnderstanding.level);
                }
                
                // Adapt Book Center based on understanding
                this.adaptBookCenterToUnderstanding();
                
                // Detect insights and breakthroughs
                this.detectChapterInsights();
                
                // Apply neural multimodal feedback
                this.applyNeuralFeedback();
            }
            
            // 🎯 PC TICKR INTEGRATION - Get real heart rate data from PC
            async fetchRealTickrData() {
                try {
                    const response = await fetch('/neural/analysis', {
                        method: 'GET',
                        timeout: 2000
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        // 🎯 SIGNAL QUALITY CHECK: Validate authentic live signal
                        console.log('🔍 SIGNAL CHECK: Validating signal for BPM:', result.bpm, 'HRV:', result.hrv_value);
                        const signalValid = this.isValidLiveSignal(result);
                        console.log('🔍 SIGNAL RESULT:', signalValid ? 'VALID' : 'INVALID');
                        
                        // ✅ SIGNAL VALIDATION: Accept live neural data if available
                        if (result.live === true && result.soul_metrics) {
                            console.log('✅ LIVE NEURAL DATA: Using authenticated Soul Metrics from backend');
                            this.hasLiveSignal = true;
                            this.signalStatus = "LIVE_NEURAL";
                            
                            // Use real-time Soul Metrics from neural processing
                            this.soulMetrics = {
                                coherence: result.soul_metrics.coherence || 30,
                                vitality: result.soul_metrics.vitality || 25, 
                                ethics: result.soul_metrics.ethics || 40,
                                narrative: result.soul_metrics.narrative || 35
                            };
                            
                            console.log('✅ LIVE SOUL METRICS UPDATED:', this.soulMetrics);
                            return result;
                        }
                        
                        // Fallback validation for cases where neural data is not ready
                        if (!signalValid || result.hrv_value === 0) {
                            console.log('🚫 SIGNAL VALIDATION FAILED - Using baseline Soul Metrics');
                            this.hasLiveSignal = false;
                            this.signalStatus = result.hrv_value === 0 ? "BELT_REMOVED" : "POOR_SIGNAL";
                            // Signal validation failed - live flag already set above
                            return null;
                        }
                        
                        console.log(`🔍 LIVE DATA CHECK: BPM=${result.bpm}, live=${result.live}, live_type=${typeof result.live}, device=${result.device}`);
                        console.log(`🔍 VALIDATION CHECK: bpm_check=${!!result.bpm}, live_check=${result.live === true}, combined=${result.bpm && result.live === true}`);
                        
                        if (result.bpm && result.live === true) {
                            console.log(`🎯 LIVE DATA: ${result.bpm} BPM, HRV: ${result.hrv_value}ms from ${result.device}`);
                            
                            // Update HRV system with unified schema data
                            // ✅ CRITICAL: Ensure systemMetrics.hrv exists before updating
                            if (!this.systemMetrics.hrv) {
                                this.systemMetrics.hrv = {};
                            }
                            
                            this.systemMetrics.hrv = {
                                ...this.systemMetrics.hrv,
                                hrv: result.hrv_value, // Use hrv_value from unified schema
                                coherence: this.calculateHRVCoherence(result.bpm),
                                variability: this.calculateHRVVariability(result.bpm),
                                authentic_data: true,
                                source: result.source + '_' + result.device,
                                heart_rate: result.bpm,
                                last_update: new Date(result.ts)
                            };
                            
                            // ✅ CRITICAL: Mark as having live signal
                            this.hasLiveSignal = true;
                            this.signalStatus = "LIVE";
                            
                            // ✅ CRITICAL: Signal restored - live flag managed centrally
                            
                            // ✅ CLEAR GLOBAL FLAG when signal is restored
                            window.experience = window.experience || {};
                            window.experience.motionFrozen = false;
                            
                            console.log('✅ SIGNAL RESTORED - signalLost flag cleared, Soul Metrics updates enabled');
                            
                            // ✅ CRITICAL: Ensure soulMetrics exists before updating
                            if (!this.soulMetrics) {
                                this.soulMetrics = { coherence: 80, vitality: 80, ethics: 80, narrative: 80 };
                            }
                            
                            // ✅ FIXED SOUL METRICS LOGGING - VERSION 2.0
                            console.log('🧠 NEW SOUL METRICS SYSTEM ACTIVE [v2.0]');
                            console.log('   → Current soulMetrics BEFORE:', JSON.stringify(this.soulMetrics, null, 2));
                            console.log('   → Input BPM:', result.bpm, 'HRV:', result.hrv_value);
                            console.log('   → Calculated coherence from HR:', this.systemMetrics.hrv.coherence);
                            
                            try {
                                // Update coherence
                                const oldCoherence = this.soulMetrics.coherence;
                                this.soulMetrics.coherence = Math.min(100, this.systemMetrics.hrv.coherence);
                                console.log('   → Coherence UPDATED: ', oldCoherence, '→', this.soulMetrics.coherence);
                                
                                // Update vitality 
                                const oldVitality = this.soulMetrics.vitality;
                                console.log('🔍 NEW DEBUG: About to calculate vitality for BPM:', result.bpm);
                                const calculatedVitality = this.calculateVitalityFromHR(result.bpm);
                                console.log('🔍 NEW DEBUG: Vitality calculation result:', calculatedVitality);
                                this.soulMetrics.vitality = calculatedVitality;
                                console.log('   → Vitality UPDATED: ', oldVitality, '→', this.soulMetrics.vitality);
                                
                                // ✅ CRITICAL: Update other Soul Metrics from HRV
                                const oldEthics = this.soulMetrics.ethics;
                                const oldNarrative = this.soulMetrics.narrative;
                                
                                // Ethics based on HRV stability (higher HRV = more ethical decisions)
                                this.soulMetrics.ethics = result.hrv_value ? 
                                    Math.min(100, 60 + (result.hrv_value * 2)) : 80;
                                
                                // Narrative based on coherence and heart rate balance
                                this.soulMetrics.narrative = Math.min(100, 
                                    (this.soulMetrics.coherence * 0.6) + (this.soulMetrics.vitality * 0.4));
                                
                                console.log('   → Ethics UPDATED: ', oldEthics, '→', this.soulMetrics.ethics);
                                console.log('   → Narrative UPDATED: ', oldNarrative, '→', this.soulMetrics.narrative);
                                
                                console.log('🧠 NEW SOUL METRICS UPDATE COMPLETE [v2.0]');
                                console.log('   → Final soulMetrics AFTER:', JSON.stringify(this.soulMetrics, null, 2));
                                
                            } catch (error) {
                                console.error('❌ NEW Soul metrics update error:', error.message);
                                console.log('🔍 NEW Error details:', error);
                            }
                            
                            // Log unified schema data usage
                            console.log('✅ LIVE SIGNAL ACTIVE - Data updated:', {
                                heart_rate: result.bpm,
                                hrv_value: result.hrv_value,
                                coherence: this.systemMetrics.hrv.coherence,
                                vitality: this.soulMetrics.vitality,
                                device: result.device,
                                live: result.live
                            });
                            
                            return result;
                        }
                    } else {
                        console.log('🚫 /live-data endpoint error:', response.status);
                        this.hasLiveSignal = false;
                        this.signalStatus = "DISCONNECTED";
                    }
                } catch (error) {
                    console.log('🚫 /live-data fetch error:', error.message);
                    this.hasLiveSignal = false;
                    this.signalStatus = "DISCONNECTED";
                }
                
                return null; // Return null if no authentic data available
            }
            
            // ✅ SIGNAL QUALITY VALIDATION: Detect when belt is removed
            isValidLiveSignal(result) {
                const now = Date.now();
                
                // Track signal history for pattern detection
                if (!this.signalHistory) {
                    this.signalHistory = [];
                }
                
                // Add current reading to history
                this.signalHistory.push({
                    timestamp: now,
                    bpm: result.bpm,
                    hrv: result.hrv_value,
                    rr: result.rr ? result.rr.length : 0
                });
                
                // Keep only last 10 readings (20 seconds of data)
                if (this.signalHistory.length > 10) {
                    this.signalHistory.shift();
                }
                
                // 🚫 CRITICAL CHECKS for signal validity
                
                // 1. Check for "frozen" heart rate (too little variation for too long)
                if (this.signalHistory.length >= 5) {
                    const lastFiveReadings = this.signalHistory.slice(-5);
                    const bpmValues = lastFiveReadings.map(r => r.bpm);
                    const minBpm = Math.min(...bpmValues);
                    const maxBpm = Math.max(...bpmValues);
                    const variation = maxBpm - minBpm;
                    
                    // Accept any variation, even 0 - TICKR can be very stable during rest
                    console.log(`✅ SIGNAL VARIATION: ${variation} BPM over last 5 readings - ACCEPTING ALL AUTHENTIC TICKR DATA`);
                    console.log(`🔍 SIGNAL HISTORY: BPM values: [${bpmValues.join(', ')}]`);
                }
                
                // 2. Check for unrealistic HRV patterns (only null)
                if (result.hrv_value === null || result.hrv_value === undefined) {
                    console.log('🚫 SIGNAL QUALITY: Null/undefined HRV - no valid signal');
                    return false;
                }
                // NOTE: HRV=0 is physiologically possible and should not be rejected
                
                // 3. Check RR interval availability
                if (!result.rr || result.rr.length === 0) {
                    console.log('🚫 SIGNAL QUALITY: No RR intervals - weak signal');
                    return false;
                }
                
                // 4. Timestamp freshness check (data should be recent)
                const dataAge = now - result.ts;
                if (dataAge > 5000) { // Older than 5 seconds
                    console.log('🚫 SIGNAL QUALITY: Stale data - signal interrupted');
                    return false;
                }
                
                // ✅ Signal passes all quality checks
                console.log('✅ SIGNAL QUALITY: Valid live signal confirmed');
                return true;
            }
            
            // Calculate HRV coherence from heart rate
            calculateHRVCoherence(heartRate) {
                // HRV coherence based on heart rate variability patterns
                // Optimal range: 55-85 BPM for good coherence
                if (heartRate >= 55 && heartRate <= 85) {
                    return Math.min(95, 60 + (85 - Math.abs(heartRate - 70)) * 2);
                } else if (heartRate < 55) {
                    return Math.max(40, 50 - (55 - heartRate));
                } else {
                    return Math.max(35, 85 - (heartRate - 85) * 1.5);
                }
            }
            
            // Calculate vitality from heart rate - SIMPLIFIED FOR LIVE TICKR DATA
            calculateVitalityFromHR(heartRate) {
                // ✅ SIMPLIFIED: Calculate vitality directly from heart rate
                console.log('🔍 DEBUG: Calculating vitality for HR:', heartRate);
                
                if (heartRate >= 70 && heartRate <= 90) {
                    const vitality = Math.min(95, 70 + (heartRate - 60));
                    console.log('✅ Vitality calculated (optimal range):', vitality);
                    return vitality;
                } else if (heartRate < 60) {
                    const vitality = Math.max(50, heartRate + 10);
                    console.log('✅ Vitality calculated (low HR):', vitality);
                    return vitality;
                } else {
                    const vitality = Math.max(40, 110 - heartRate);
                    console.log('✅ Vitality calculated (high HR):', vitality);
                    return vitality;
                }
            }
            
            // Calculate HRV variability estimation - ONLY FROM VALID FRAMES
            calculateHRVVariability(heartRate) {
                // 🚫 STRICT: No calculations without valid authenticated frames
                if (!this.isValidFrame(this.lastHRVFrame)) {
                    return null;
                }
                return Math.max(20, Math.min(80, 60 - Math.abs(heartRate - 75)));
            }
            
            // 🚫 CRITICAL: Check live signal status for motion freeze
            async checkLiveSignalStatus() {
                try {
                    const response = await fetch('/api/signal/status');
                    if (response.ok) {
                        const result = await response.json();
                        
                        // 🚫 CRITICAL MOTION FREEZE CONTROL
                        this.hasLiveSignal = result.signal;
                        this.signalStatus = result.status;
                        this.debugOverlay = result.debug_overlay;
                        
                        if (!this.hasLiveSignal) {
                            console.log('🚫 NO LIVE SIGNAL - FREEZING YOU NODE MOTION');
                            return false; // Motion disabled
                        } else {
                            console.log('✅ LIVE SIGNAL ACTIVE - Motion enabled');
                            return true; // Motion enabled
                        }
                    }
                } catch (error) {
                    console.log('🚫 Signal status check failed - FREEZING motion');
                    this.hasLiveSignal = false;
                    this.resetHRVDataOnDisconnect(); // Reset data on error
                    return false;
                }
                return false;
            }

            // 🚫 CRITICAL: Complete state reset on signal disconnect
            resetHRVDataOnDisconnect() {
                console.log('🚫 COMPLETE STATE RESET - Signal disconnected');
                
                // Reset all HRV metrics to null
                this.systemMetrics.hrv = {
                    hrv: null,
                    breath: null,
                    coherence: null,
                    focus: null,
                    heart_rate: null,
                    variability: null
                };
                
                // Clear all cached neural results
                this.neuralHRVResult = null;
                this.lastHRVUpdate = null;
                
                // Stop all animations and motion
                this.stopAllAnimations();
                
                // Reset YOU node to frozen state
                this.freezeYouNode();
                
                // Update UI to show N/A values and maintain them
                this.updateUIWithNoSignal();
                
                // Disable AI/Presence movements
                this.disableAIMovements();
            }
            
            // Stop all requestAnimationFrame loops
            stopAllAnimations() {
                console.log('🚫 STOPPING ALL ANIMATIONS');
                
                // Cancel any pending animation frames
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                // Stop particle animations
                if (this.particleAnimationId) {
                    cancelAnimationFrame(this.particleAnimationId);
                    this.particleAnimationId = null;
                }
                
                // Stop consciousness mapping animations
                if (this.consciousnessAnimationId) {
                    cancelAnimationFrame(this.consciousnessAnimationId);
                    this.consciousnessAnimationId = null;
                }
            }
            
            // Freeze YOU node completely
            freezeYouNode() {
                console.log('🚫 FREEZING YOU NODE - No movement allowed');
                
                // Initialize youNode if missing
                if (!this.youNode) {
                    this.youNode = {
                        frozen: false,
                        velocity: { x: 0, y: 0 },
                        acceleration: { x: 0, y: 0 },
                        opacity: 1.0,
                        active: false,
                        hasTrail: false
                    };
                }
                
                // Stop YOU node physics
                this.youNode.frozen = true;
                this.youNode.velocity = { x: 0, y: 0 };
                this.youNode.acceleration = { x: 0, y: 0 };
                
                // Dim the visual appearance
                this.youNode.opacity = 0.4;
                this.youNode.active = false;
                this.youNode.hasTrail = false;
            }
            
            // Disable all AI/Presence movements
            disableAIMovements() {
                console.log('🚫 DISABLING AI MOVEMENTS - No HRV-dependent motion');
                
                // Stop presence agent movements
                this.presenceMovementEnabled = false;
                
                // Freeze spatial intelligence
                this.spatialIntelligenceEnabled = false;
                
                // Stop personality evolution
                this.personalityEvolutionEnabled = false;
            }
            
            // Update UI to display N/A when no signal and lock values
            updateUIWithNoSignal() {
                console.log('🚫 LOCKING UI TO N/A VALUES');
                
                const elements = {
                    'hrvValue': 'N/A',
                    'breathRate': 'N/A', 
                    'hrvCoherence': 'N/A',
                    'focusValue': 'N/A',
                    'heartRateValue': 'N/A'
                };
                
                Object.entries(elements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = value;
                        element.style.color = '#888'; // Dimmed appearance
                    }
                });
                
                // 🚫 Show "SYSTEM DISCONNECTED" overlay
                this.showCriticalDisconnectOverlay();
                
                // Lock metrics display - prevent updates until signal returns
                this.metricsLocked = true;
            }
            
            // Complete UI state reset (called immediately on signal loss)
            resetUIState() {
                console.log('🚫 COMPLETE UI STATE RESET');
                
                // Reset all variables
                this.resetHRVDataOnDisconnect();
                
                // Clear all visual effects
                this.clearVisualEffects();
                
                // Reset canvas elements
                this.resetCanvasElements();
                
                // Show disconnected state
                this.showDisconnectedState();
            }
            
            // Clear all visual effects
            clearVisualEffects() {
                // Clear particle trails
                const canvas = document.getElementById('youCanvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                
                // Reset glow effects
                document.querySelectorAll('.glow-effect').forEach(el => {
                    el.classList.remove('glow-effect');
                });
            }
            
            // Reset canvas elements to static state
            resetCanvasElements() {
                const canvases = ['youCanvas', 'particleCanvas', 'consciousnessCanvas'];
                canvases.forEach(canvasId => {
                    const canvas = document.getElementById(canvasId);
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                });
            }
            
            // Show disconnected state visually
            showDisconnectedState() {
                // Add disconnected styling to main container
                const container = document.querySelector('.book-centers-container');
                if (container) {
                    container.classList.add('signal-disconnected');
                }
                
                // Show "NO SIGNAL" overlay
                this.showNoSignalOverlay();
            }
            
            // Show NO SIGNAL overlay
            showNoSignalOverlay() {
                let overlay = document.getElementById('noSignalOverlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'noSignalOverlay';
                    overlay.innerHTML = '🚫 NO SIGNAL - Awaiting TICKR Connection';
                    overlay.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: rgba(255, 0, 0, 0.8);
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        z-index: 10000;
                        font-weight: bold;
                    `;
                    document.body.appendChild(overlay);
                }
                overlay.style.display = 'block';
            }
            
            // Hide NO SIGNAL overlay when signal returns
            hideNoSignalOverlay() {
                const overlay = document.getElementById('noSignalOverlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
                
                // Remove disconnected styling
                const container = document.querySelector('.book-centers-container');
                if (container) {
                    container.classList.remove('signal-disconnected');
                }
                
                // Unlock metrics
                this.metricsLocked = false;
                
                // Restore normal UI colors
                const elements = ['hrvValue', 'breathRate', 'hrvCoherence', 'focusValue'];
                elements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.color = ''; // Reset to default
                    }
                });
            }

            // 🚫 CRITICAL: Signal monitoring system (runs every 2 seconds)
            startSignalMonitoring() {
                console.log('🚫 Signal monitoring started - Critical for motion freeze');
                setInterval(() => {
                    const canMove = (this.hasLiveSignal === true);
                    const wasConnected = !this.motionFrozen;
                    this.motionFrozen = !canMove;
                    
                    if (this.motionFrozen && wasConnected) {
                        // Signal just lost - immediate complete reset
                        console.log('🚫 SIGNAL LOST - IMMEDIATE COMPLETE RESET');
                        this.resetUIState(); // Complete state reset
                        this.showNoSignalOverlay();
                    } else if (!this.motionFrozen && !wasConnected) {
                        // Signal just restored - re-enable everything
                        console.log('✅ SIGNAL RESTORED - Re-enabling systems');
                        this.hideNoSignalOverlay();
                        this.enableAllSystems();
                    }
                }, 2000); // Check every 2 seconds - faster response
            }
            
            // Re-enable all systems when signal returns
            enableAllSystems() {
                console.log('✅ RE-ENABLING ALL SYSTEMS');
                
                // Re-enable movements
                this.presenceMovementEnabled = true;
                this.spatialIntelligenceEnabled = true;
                this.personalityEvolutionEnabled = true;
                
                // Unfreeze YOU node
                this.youNode.frozen = false;
                this.youNode.active = true;
                this.youNode.hasTrail = true;
                this.youNode.opacity = 0.98;
                
                // Unlock metrics
                this.metricsLocked = false;
                
                // Restart animations if needed
                this.restartAnimations();
            }
            
            // Restart animations when signal returns
            restartAnimations() {
                // Only restart if we have live signal
                if (this.hasLiveSignal && !this.motionFrozen) {
                    console.log('✅ RESTARTING ANIMATIONS');
                    this.startMainAnimationLoop();
                }
            }
            
            // 🚫 CRITICAL: Complete hard reset on server disconnect
            performHardReset() {
                console.log('🚫 PERFORMING HARD RESET - Complete system shutdown');
                
                // Immediately reset all state
                this.resetUIState();
                
                // Force disconnect WebSocket if needed
                if (this.socket && this.socket.connected) {
                    this.socket.disconnect();
                }
                
                // Clear all intervals and timeouts
                this.clearAllTimers();
                
                // Reset to initial state
                this.initializeDefaultState();
                
                // Show critical disconnect overlay
                this.showCriticalDisconnectOverlay();
            }
            
            // Clear all running timers
            clearAllTimers() {
                if (this.pcTickrInterval) {
                    clearInterval(this.pcTickrInterval);
                    this.pcTickrInterval = null;
                }
                
                if (this.signalMonitoringInterval) {
                    clearInterval(this.signalMonitoringInterval);
                    this.signalMonitoringInterval = null;
                }
            }
            
            // Reset to complete initial state
            initializeDefaultState() {
                this.hasLiveSignal = false;
                this.motionFrozen = true;
                this.metricsLocked = true;
                this.neuralHRVResult = null;
                this.lastHRVUpdate = null;
                this.connected = false;
            }
            
            // Show critical disconnect overlay
            showCriticalDisconnectOverlay() {
                let overlay = document.getElementById('criticalDisconnectOverlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'criticalDisconnectOverlay';
                    overlay.innerHTML = '🚫 SYSTEM DISCONNECTED - No live TICKR signal';
                    overlay.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(255, 0, 0, 0.9);
                        color: white;
                        padding: 30px 50px;
                        border-radius: 10px;
                        z-index: 20000;
                        font-weight: bold;
                        font-size: 18px;
                        text-align: center;
                        border: 3px solid #fff;
                    `;
                    document.body.appendChild(overlay);
                }
                overlay.style.display = 'block';
            }
            
            // 🚫 STRICT: Hard gate for frame validation
            isValidFrame(f) {
                return f && f.type === "hrv_frame" && f.live === true && f.source === "tickr" && (Date.now() - f.ts) <= 2000;
            }
            
            // 🚫 CRITICAL: Hard rendering gate
            renderHRVData() {
                const connected = this.wsConnected === true;
                
                if (!(connected && this.isValidFrame(this.lastHRVFrame))) {
                    this.lockUIToNoSignal();
                    return;
                }
                
                // Only render if we have valid authenticated frame
                this.renderValidHRV(this.lastHRVFrame);
            }
            
            // 🚫 STRICT: Client-side frame validation (legacy support)
            validateHRVFrame(frame) {
                return this.isValidFrame(frame);
            }
            
            // 🚫 STRICT: Process only validated frames
            processIncomingTelemetry(data) {
                // Store frame for validation
                this.lastHRVFrame = data;
                
                // UI integrity check
                this.checkUIIntegrity();
                
                // Frame validation gate
                if (!this.isValidFrame(data)) {
                    this.lockUIToNoSignal();
                    return;
                }
                
                // Valid frame - unlock UI and process
                this.unlockUIFromNoSignal();
                this.updateHRVMetrics(data);
            }
            
            // 🚫 UI integrity check (console error for illegal states)
            checkUIIntegrity() {
                const connected = this.wsConnected === true;
                const validFrame = this.isValidFrame(this.lastHRVFrame);
                const hasHRVData = this.systemMetrics.hrv.hrv !== null;
                
                if ((!connected || !validFrame) && hasHRVData) {
                    console.error('🚨 ILLEGAL_HRV_OFFLINE: HRV data present without valid connection/frame');
                    // Auto-null illegal data
                    this.setHRV(null);
                    this.setBreath(null);
                    this.setCoherence(null);
                    this.forceHardDisconnect('ILLEGAL_STATE');
                }
            }
            
            // 🚫 Force hard disconnect with reason
            forceHardDisconnect(reason) {
                console.log(`🚫 FORCE HARD DISCONNECT: ${reason}`);
                this.stopAllAnimations();
                this.freezeYouNode();
                this.setHRV(null);
                this.setBreath(null); 
                this.setCoherence(null);
                this.showCriticalDisconnectOverlay(`SYSTEM DISCONNECTED – ${reason}`);
                this.wsConnected = false;
                this.hasLiveSignal = false;
            }
            
            // Lock UI when no valid frames
            lockUIToNoSignal() {
                this.hasLiveSignal = false;
                this.motionFrozen = true;
                this.metricsLocked = true;
                
                // Complete data wipe
                this.setHRV(null);
                this.setBreath(null);
                this.setCoherence(null);
                
                this.showCriticalDisconnectOverlay();
            }
            
            // Unlock UI when valid frames return
            unlockUIFromNoSignal() {
                this.hasLiveSignal = true;
                this.motionFrozen = false;
                this.metricsLocked = false;
                
                // Hide disconnect overlay
                const overlay = document.getElementById('criticalDisconnectOverlay');
                if (overlay) overlay.style.display = 'none';
            }
            
            // 🚫 Null setters for complete data wipe
            setHRV(value) {
                this.systemMetrics.hrv.hrv = value;
                const element = document.getElementById('hrvValue');
                if (element) element.textContent = value === null ? 'N/A' : value;
            }
            
            setBreath(value) {
                this.systemMetrics.hrv.breath = value;
                const element = document.getElementById('breathRate');
                if (element) element.textContent = value === null ? 'N/A' : value;
            }
            
            setCoherence(value) {
                this.systemMetrics.hrv.coherence = value;
                const element = document.getElementById('hrvCoherence');
                if (element) element.textContent = value === null ? 'N/A' : value;
            }

            // Initialize PC TICKR data fetching loop
            initializePCTickrFetching() {
                console.log('🎯 Initializing PC TICKR data fetching every 3 seconds');
                
                // Initial fetch
                this.fetchRealTickrData();
                
                // Set up recurring fetch every 3 seconds
                this.pcTickrInterval = setInterval(() => {
                    this.fetchRealTickrData().then(data => {
                        if (data) {
                            // Update the YOU interface with real biometric data
                            this.updateYouInterface();
                            
                            // Update consciousness mapping with authentic data
                            this.updateConsciousnessMapping();
                        }
                    });
                }, 3000); // Fetch every 3 seconds
                
                console.log('✅ PC TICKR data fetching initialized');
            }

            // NEURAL HRV INTEGRATION - Authentic TICKR data only
            async processNeuralHRV() {
                // 🚫 CRITICAL SIGNAL CHECK - No processing without live signal
                if (!this.hasLiveSignal || this.motionFrozen) {
                    console.log('🚫 NO LIVE SIGNAL - Neural processing disabled');
                    this.neuralHRVResult = null; // Clear any cached data
                    return null;
                }
                
                // First try to get real PC TICKR data
                const realTickrData = await this.fetchRealTickrData();
                
                if (!realTickrData) {
                    console.log('🚫 NO TICKR DATA - Neural processing disabled');
                    this.neuralHRVResult = null; // Clear cached results
                    return null;
                }
                
                // ✅ AUTHENTIC DATA CONFIRMED - Mark as having live signal
                console.log('✅ AUTHENTIC TICKR DATA RECEIVED - Processing enabled');
                this.hasLiveSignal = true;
                this.signalStatus = "LIVE";
                
                // Use only authentic TICKR data
                const hrvData = {
                    hrv: realTickrData.hrv || 0,
                    breath: realTickrData.breath_rate || 0,
                    coherence: realTickrData.coherence || 0,
                    focus: realTickrData.focus || 0,
                    lf: realTickrData.lf || 0,
                    hf: realTickrData.hf || 0,
                    authentic_source: realTickrData.device_name,
                    heart_rate: realTickrData.heart_rate
                };
                console.log('🎯 USING AUTHENTIC TICKR DATA from PC for neural processing');
                
                // Send to neural backend (async)
                fetch('/api/neural-hrv', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(hrvData)
                })
                .then(response => response.json())
                .then(result => {
                    this.neuralHRVResult = result;
                    
                    // Log neural analysis
                    console.log(`🧠 Neural HRV Analysis: Understanding ${Math.round(result.understanding_level*100)}%, Risk: ${result.risk_detection}`);
                    
                    // Update memory with neural insights
                    this.memoryItems.push({
                        content: `🧬 Neural Analysis: ${Math.round(result.understanding_level*100)}% understanding, Latent coherence: ${result.latent_coherence.toFixed(2)}`,
                        timestamp: new Date().toLocaleTimeString(),
                        type: 'neural_analysis'
                    });
                })
                .catch(error => {
                    console.log('Neural HRV fallback mode:', error.message);
                    this.neuralHRVResult = null;
                });
            }
            
            applyNeuralFeedback() {
                if (!this.neuralHRVResult) return;
                
                const centerElement = document.getElementById('center1');
                if (!centerElement) return;
                
                // Apply sound feedback (visual representation)
                const soundFreq = this.neuralHRVResult.sound_frequency;
                const lightIntensity = this.neuralHRVResult.light_intensity;
                const understandingLevel = this.neuralHRVResult.understanding_level;
                
                // Sound frequency affects pulsing speed
                const pulseSpeed = Math.max(0.5, Math.min(3.0, soundFreq / 200));
                centerElement.style.animationDuration = `${pulseSpeed}s`;
                
                // Light intensity affects glow
                const glowIntensity = Math.max(0.1, Math.min(1.0, lightIntensity));
                const currentGlow = parseInt(centerElement.style.boxShadow?.match(/\d+/)?.[0] || '0');
                centerElement.style.boxShadow = `0 0 ${currentGlow}px rgba(79, 172, 254, ${glowIntensity})`;
                
                // HRV-DRIVEN SYSTEM UPDATES
                this.updateAllSystemsFromHRV(this.neuralHRVResult, understandingLevel);
                
                // Risk detection visual warning
                if (this.neuralHRVResult.risk_detection) {
                    centerElement.style.border = '2px solid rgba(239, 68, 68, 0.8)';
                    
                    this.memoryItems.push({
                        content: '⚠️ Neural Risk Detection: Διακόπτετε για ένα λεπτό και επικεντρωθείτε στην αναπνοή',
                        timestamp: new Date().toLocaleTimeString(),
                        type: 'risk_warning'
                    });
                } else {
                    centerElement.style.border = 'none';
                }
                
                // Keep only recent memory items
                if (this.memoryItems.length > 12) {
                    this.memoryItems.shift();
                }
            }
            
            // HRV-DRIVEN COMPREHENSIVE SYSTEM UPDATES
            updateAllSystemsFromHRV(neuralResult, understandingLevel) {
                // 1. UPDATE USER EVOLUTION based on HRV insights
                this.updateUserEvolutionFromHRV(neuralResult, understandingLevel);
                
                // 2. UPDATE AI ADAPTATION based on neural analysis
                this.updateAIAdaptationFromHRV(neuralResult);
                
                // 3. UPDATE MEMORY SYSTEM with HRV-based insights
                this.updateMemoryFromHRV(neuralResult, understandingLevel);
                
                // 4. UPDATE ANOMALY DETECTION with neural patterns
                this.updateAnomalyDetectionFromHRV(neuralResult);
                
                // 5. UPDATE SOUL METRICS with HRV coherence data
                this.updateSoulMetricsFromHRV(neuralResult, understandingLevel);
                
                console.log('🧬 All systems updated from Neural HRV analysis');
            }
            
            updateUserEvolutionFromHRV(neuralResult, understandingLevel) {
                // HRV-driven personality evolution
                const latentCoherence = neuralResult.latent_coherence || 0;
                const soundFreq = neuralResult.sound_frequency || 440;
                const lightIntensity = neuralResult.light_intensity || 0.5;
                
                // Initialize with low values if not set (allowing growth)
                if (!this.userEvolution.initialized) {
                    this.userEvolution.currentPersonality = {
                        empathy: 0.3,
                        creativity: 0.4,
                        resilience: 0.35,
                        focus: 0.25,
                        curiosity: 0.45,
                        compassion: 0.3
                    };
                    this.userEvolution.initialized = true;
                    console.log('🧠 User Evolution Initialized with growth potential:', this.userEvolution.currentPersonality);
                }
                
                // Update personality traits based on neural analysis
                const current = this.userEvolution.currentPersonality;
                
                // Empathy evolves with light intensity and coherence
                current.empathy = Math.min(1, current.empathy + (lightIntensity - 0.5) * 0.015);
                
                // Creativity evolves with sound frequency variation
                const freqVariation = Math.abs(soundFreq - 440) / 440;
                current.creativity = Math.min(1, current.creativity + freqVariation * 0.01);
                
                // Resilience based on risk handling
                if (neuralResult.risk_detection) {
                    current.resilience = Math.max(0.2, current.resilience - 0.015);
                } else {
                    current.resilience = Math.min(1, current.resilience + 0.01);
                }
                
                // Focus directly correlated with understanding
                current.focus = Math.min(1, current.focus + (understandingLevel - 0.5) * 0.02);
                
                // Curiosity enhanced by neural insights detection
                if (neuralResult.insights && neuralResult.insights.length > 0) {
                    current.curiosity = Math.min(1, current.curiosity + 0.015);
                }
                
                // Compassion grows with stable HRV patterns
                current.compassion = Math.min(1, current.compassion + latentCoherence * 0.01);
                
                // Record evolution event
                this.userEvolution.evolutionHistory.push({
                    timestamp: new Date().toLocaleTimeString(),
                    personality: {...current},
                    trigger: 'neural_hrv_analysis',
                    understanding_level: understandingLevel,
                    neural_insights: neuralResult.insights || []
                });
                
                // HAWKINS NEURAL EVOLUTION LOGGING - Throttled to 60s
                const currentTime = Date.now();
                this.logEvolutionSmarter(current, currentTime, 'neural');
            }
            
            updateAIAdaptationFromHRV(neuralResult) {
                // AI adapts its response based on HRV neural analysis
                const adaptationFactors = {
                    understanding_boost: neuralResult.understanding_level > 0.7 ? 1.2 : 1.0,
                    risk_mitigation: neuralResult.risk_detection ? 0.8 : 1.0,
                    coherence_alignment: neuralResult.latent_coherence > 0.6 ? 1.1 : 0.9
                };
                
                // Update AI personality weights based on user's neural state
                this.systemMetrics.ai_adaptation = {
                    understanding_focus: adaptationFactors.understanding_boost,
                    safety_protocol: adaptationFactors.risk_mitigation,
                    coherence_sync: adaptationFactors.coherence_alignment,
                    neural_insights_count: neuralResult.insights?.length || 0
                };
                
                console.log('🤖 AI Adaptation updated from HRV neural analysis');
            }
            
            updateMemoryFromHRV(neuralResult, understandingLevel) {
                // Memory encoding strength based on HRV coherence
                const memoryStrength = neuralResult.latent_coherence * 100;
                this.systemMetrics.memory.retention = Math.min(100, 85 + memoryStrength * 0.15);
                
                // Add HRV-based memory consolidation insights
                if (understandingLevel > 0.8) {
                    this.memoryItems.push({
                        content: `🧠 Deep Integration: Chapter understanding at ${Math.round(understandingLevel*100)}% - Neural patterns show strong memory consolidation`,
                        timestamp: new Date().toLocaleTimeString(),
                        type: 'neural_memory_consolidation',
                        strength: memoryStrength
                    });
                }
                
                // Memory correlation with HRV insights
                if (neuralResult.insights && neuralResult.insights.length > 0) {
                    neuralResult.insights.forEach(insight => {
                        this.memoryItems.push({
                            content: `🔍 Neural Insight: ${insight} - HRV patterns reveal deepening ${insight.replace('_', ' ')}`,
                            timestamp: new Date().toLocaleTimeString(),
                            type: 'hrv_insight',
                            neural_marker: insight
                        });
                    });
                }
                
                console.log('🧠 Memory system updated with HRV neural insights');
            }
            
            updateAnomalyDetectionFromHRV(neuralResult) {
                // Anomaly detection enhanced by neural HRV analysis
                let behaviorStatus = 'Normal';
                let insightCount = this.systemMetrics.anomaly.insights;
                
                if (neuralResult.risk_detection) {
                    behaviorStatus = 'Risk Detected';
                    insightCount += 1;
                    
                    // Log anomaly pattern
                    console.log('⚠️ HRV Anomaly detected:', {
                        understanding: neuralResult.understanding_level,
                        coherence: neuralResult.latent_coherence,
                        risk_factors: neuralResult.neural_features
                    });
                } else if (neuralResult.understanding_level > 0.8) {
                    behaviorStatus = 'Peak Performance';
                    insightCount += 1;
                } else if (neuralResult.latent_coherence > 0.7) {
                    behaviorStatus = 'High Coherence';
                }
                
                // Update anomaly metrics
                this.systemMetrics.anomaly.behavior = behaviorStatus;
                this.systemMetrics.anomaly.insights = insightCount;
                this.systemMetrics.anomaly.neural_risk_level = neuralResult.risk_detection ? 'High' : 'Low';
                this.systemMetrics.anomaly.coherence_stability = neuralResult.latent_coherence > 0.6 ? 'Stable' : 'Variable';
                
                console.log('🔮 Anomaly Detection updated with neural HRV patterns');
            }
            
            updateSoulMetricsFromHRV(neuralResult, understandingLevel) {
                // ✅ CHECK SIGNAL STATUS BEFORE NEURAL HRV UPDATES
                if (this.signalLost) {
                    console.log('🚫 SIGNAL LOST - Setting Soul Metrics to zero');
                    this.systemMetrics.soul.coherence = 0;
                    this.systemMetrics.soul.vitality = 0;
                    this.systemMetrics.soul.ethics = 0;
                    this.systemMetrics.soul.narrative = 0;
                    return;
                }
                
                // Soul Metrics enhanced by neural HRV coherence
                const baseCoherence = this.systemMetrics.soul.coherence;
                const baseVitality = this.systemMetrics.soul.vitality;
                const baseEthics = this.systemMetrics.soul.ethics;
                const baseNarrative = this.systemMetrics.soul.narrative;
                
                // Neural HRV enhances soul metrics
                this.systemMetrics.soul.coherence = Math.min(100, baseCoherence + (neuralResult.latent_coherence * 10));
                this.systemMetrics.soul.vitality = Math.min(100, baseVitality + (neuralResult.light_intensity * 15));
                this.systemMetrics.soul.ethics = Math.min(100, baseEthics + (understandingLevel * 8));
                this.systemMetrics.soul.narrative = Math.min(100, baseNarrative + (neuralResult.sound_frequency / 440 * 10));
                
                // Neural coherence bonus
                if (neuralResult.latent_coherence > 0.8) {
                    Object.keys(this.systemMetrics.soul).forEach(key => {
                        this.systemMetrics.soul[key] = Math.min(100, this.systemMetrics.soul[key] + 5);
                    });
                }
                
                console.log('✨ Soul Metrics enhanced by Neural HRV coherence');
            }
            
            calculateMindfulness() {
                // Based on HRV coherence and focus stability
                const coherenceStability = this.systemMetrics.hrv.coherence / 100;
                const focusStability = this.systemMetrics.hrv.focus / 100;
                return (coherenceStability + focusStability) / 2;
            }
            
            calculateThoughtAwareness() {
                // Based on breath awareness and HRV stability
                const breathAwareness = 1 - Math.min(1, Math.abs(16 - this.systemMetrics.hrv.breath) / 4);
                const hrvStability = this.systemMetrics.hrv.hrv / 100;
                return (breathAwareness + hrvStability) / 2;
            }
            
            calculatePresentMoment() {
                // Based on sustained focus and coherence flow
                const sustainedFocus = this.systemMetrics.hrv.focus > 70 ? 1 : this.systemMetrics.hrv.focus / 70;
                const coherenceFlow = this.systemMetrics.hrv.coherence > 80 ? 1 : this.systemMetrics.hrv.coherence / 80;
                return (sustainedFocus + coherenceFlow) / 2;
            }
            
            adaptBookCenterToUnderstanding() {
                const centerElement = document.getElementById('center1');
                if (!centerElement) return;
                
                const progress = this.chapterUnderstanding.level / 100;
                const distanceFactor = this.chapterUnderstanding.distanceToCenter / 100;
                
                // Dynamic positioning - center moves closer as understanding grows
                const baseTop = 50;
                const baseLeft = 50;
                
                // Subtle movement towards center as understanding improves
                const newTop = baseTop - (progress * 10);     // Moves up slightly
                const newLeft = baseLeft - (progress * 8);    // Moves left slightly
                
                centerElement.style.top = `${newTop}%`;
                centerElement.style.left = `${newLeft}%`;
                
                // Visual feedback for understanding level
                const opacity = 0.4 + (progress * 0.6);      // More visible as understanding grows
                const scale = 0.7 + (progress * 0.5);        // Larger as understanding grows
                const glow = progress * 30;                   // Glow intensity
                
                centerElement.style.opacity = opacity;
                centerElement.style.transform = `scale(${scale})`;
                centerElement.style.boxShadow = `0 0 ${glow}px rgba(79, 172, 254, ${progress})`;
                
                // Pulsing effect when close to full understanding
                if (progress > 0.8) {
                    centerElement.style.animation = 'pulse 1.5s ease-in-out infinite';
                }
                
                // Update alignment score to reflect understanding
                const alignmentScore = Math.round(this.chapterUnderstanding.level);
                document.getElementById('alignmentScore').textContent = alignmentScore;
                
                // Update distance display in memory stream
                this.memoryItems.push({
                    content: `🎯 Understanding: ${Math.round(progress*100)}% | Distance to PRESENCE: ${Math.round(distanceFactor*100)}%`,
                    timestamp: new Date().toLocaleTimeString(),
                    type: 'understanding_update'
                });
                
                // Keep only recent items
                if (this.memoryItems.length > 10) {
                    this.memoryItems.shift();
                }
            }
            
            detectChapterInsights() {
                const understanding = this.chapterUnderstanding.level;
                
                // Detect breakthrough moments
                if (understanding > 20 && !this.chapterUnderstanding.insights.includes('mind_separation')) {
                    this.addChapterInsight('mind_separation', 'Αρχίζετε να κατανοείτε ότι ο νους δεν είναι ο πραγματικός εαυτός σας');
                }
                
                if (understanding > 40 && !this.chapterUnderstanding.insights.includes('thought_observation')) {
                    this.addChapterInsight('thought_observation', 'Μπορείτε να παρατηρήσετε τις σκέψεις σας χωρίς να ταυτίζεστε με αυτές');
                }
                
                if (understanding > 60 && !this.chapterUnderstanding.insights.includes('present_awareness')) {
                    this.addChapterInsight('present_awareness', 'Βιώνετε την παρούσα στιγμή πέρα από τη νοητική δραστηριότητα');
                }
                
                if (understanding > 80 && !this.chapterUnderstanding.insights.includes('ego_transcendence')) {
                    this.addChapterInsight('ego_transcendence', 'Έχετε ενσωματώσει βαθιά το μάθημα "Δεν είστε ο νους σας"');
                    this.triggerCenterUnlock();
                }
            }
            
            addChapterInsight(type, message) {
                this.chapterUnderstanding.insights.push(type);
                
                // Add to memory stream with special formatting
                this.memoryItems.push({
                    content: `💡 Deep Insight: ${message}`,
                    timestamp: new Date().toLocaleTimeString(),
                    type: 'insight',
                    understanding: Math.round(this.chapterUnderstanding.level)
                });
                
                // Visual notification
                this.showChapterInsightNotification(message);
                
                console.log(`🧠 Chapter Insight: ${type} - ${Math.round(this.chapterUnderstanding.level)}% understanding`);
            }
            
            showChapterInsightNotification(message) {
                // Create floating insight notification
                const notification = document.createElement('div');
                notification.className = 'chapter-insight-notification';
                notification.innerHTML = `
                    <div style="background: linear-gradient(135deg, rgba(79, 172, 254, 0.95), rgba(34, 197, 94, 0.95)); 
                         color: white; padding: 20px; border-radius: 15px; position: fixed; 
                         top: 25%; left: 50%; transform: translateX(-50%); z-index: 1001; 
                         max-width: 450px; box-shadow: 0 12px 40px rgba(0,0,0,0.4); 
                         backdrop-filter: blur(15px); border: 1px solid rgba(255,255,255,0.2);
                         animation: slideInGlow 0.8s ease-out;">
                        <div style="font-weight: 700; margin-bottom: 10px; font-size: 16px;">
                            🧠 Κατανόηση Κεφαλαίου: "You Are Not Your Mind"
                        </div>
                        <div style="font-size: 14px; line-height: 1.4; margin-bottom: 12px;">
                            ${message}
                        </div>
                        <div style="font-size: 12px; opacity: 0.9; display: flex; justify-content: space-between;">
                            <span>Επίπεδο κατανόησης: ${Math.round(this.chapterUnderstanding.level)}%</span>
                            <span>Απόσταση από PRESENCE: ${Math.round(this.chapterUnderstanding.distanceToCenter)}%</span>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 6000);
            }
            
            triggerCenterUnlock() {
                // When full understanding is reached, unlock the PRESENCE center
                const centerElement = document.getElementById('center1');
                if (centerElement) {
                    centerElement.classList.add('fully-unlocked');
                    centerElement.style.animation = 'centerEnlightenment 3s ease-out';
                    centerElement.style.boxShadow = '0 0 50px rgba(79, 172, 254, 1), 0 0 100px rgba(34, 197, 94, 0.6)';
                    centerElement.style.transform = 'scale(1.2)';
                    
                    this.memoryItems.push({
                        content: '🎉 ΕΝΣΩΜΑΤΩΣΗ ΟΛΟΚΛΗΡΩΘΗΚΕ! Έχετε πλήρως κατανοήσει "You Are Not Your Mind"',
                        timestamp: new Date().toLocaleTimeString(),
                        type: 'enlightenment',
                        understanding: 100
                    });
                    
                    console.log('🎉 PRESENCE Center Fully Unlocked! Chapter Understanding Complete!');
                }
            }
        }
        
        // Removed duplicate initialization - handled by main DOMContentLoaded event
        
        function toggleChat() {
            // Future chat integration
            console.log('Chat integration coming soon...');
        }
        
        // SPATIAL DEMO FUNCTIONALITY
        let spatialDemoActive = false;
        let spatialTimer = null;
        let spatialMinutes = 5;
        let spatialSeconds = 0;
        let aiIsSeekingUser = false;
        let userAutoPosition = { x: 10, y: 45 };
        let presencePosition = { x: 60, y: 30 };
        
        function toggleSpatialDemo() {
            const btn = document.getElementById('spatialDemoBtn');
            const timer = document.getElementById('spatialTimer');
            const presenceZone = document.getElementById('presenceZoneDemo');
            
            if (!spatialDemoActive) {
                // Start spatial demo
                spatialDemoActive = true;
                btn.textContent = '⏹️ Stop Demo';
                btn.style.background = 'linear-gradient(135deg, #dc2626, #ef4444)';
                timer.style.display = 'inline-block';
                presenceZone.classList.add('active');
                
                // Start 5-minute timer
                spatialMinutes = 5;
                spatialSeconds = 0;
                updateSpatialTimer();
                
                spatialTimer = setInterval(() => {
                    if (spatialSeconds > 0) {
                        spatialSeconds--;
                    } else if (spatialMinutes > 0) {
                        spatialMinutes--;
                        spatialSeconds = 59;
                    } else {
                        // Timer finished
                        clearInterval(spatialTimer);
                        stopSpatialDemo();
                        return;
                    }
                    updateSpatialTimer();
                }, 1000);
                
                // Start AI seeking behavior
                startAISeeking();
                
                console.log('🚀 Spatial Demo Started - 5 minutes of spatial AI interaction');
            } else {
                stopSpatialDemo();
            }
        }
        
        function stopSpatialDemo() {
            spatialDemoActive = false;
            const btn = document.getElementById('spatialDemoBtn');
            const timer = document.getElementById('spatialTimer');
            const presenceZone = document.getElementById('presenceZoneDemo');
            
            btn.textContent = '🚀 5min Spatial Demo';
            btn.style.background = 'linear-gradient(135deg, #ff6b35, #ff8c42)';
            timer.style.display = 'none';
            presenceZone.classList.remove('active');
            
            if (spatialTimer) {
                clearInterval(spatialTimer);
                spatialTimer = null;
            }
            
            aiIsSeekingUser = false;
            
            // Stop fractal memory stream
            stopActiveMemoryStream();
            
            console.log('⏹️ Spatial Demo Stopped');
            console.log('🌀 Fractal manifold visualization deactivated');
        }
        
        function updateSpatialTimer() {
            const timer = document.getElementById('spatialTimer');
            timer.textContent = `${spatialMinutes}:${spatialSeconds.toString().padStart(2, '0')}`;
        }
        
        function startAISeeking() {
            aiIsSeekingUser = true;
            const presenceZone = document.getElementById('presenceZoneDemo');
            presenceZone.style.animation = 'presenceSeekingPulse 2s ease-in-out infinite';
            
            // ACTIVATE FRACTAL MANIFOLD VISUALIZATIONS
            const fractalOverlay = document.getElementById('fractalManifoldOverlay');
            const memoryStream = document.getElementById('memoryStreamVisual');
            fractalOverlay.classList.add('active');
            memoryStream.classList.add('active');
            
            // Simulate user movement with mouse tracking
            document.addEventListener('mousemove', updateUserPositionFromMouse);
            
            // Start AI movement logic
            requestAnimationFrame(updateAIPosition);
            
            // Start fractal memory stream updates
            startActiveMemoryStream();
            
            console.log('🤖 AI PRESENCE is now seeking your position...');
            console.log('🌀 Fractal manifold visualization activated!');
        }
        
        function updateUserPositionFromMouse(event) {
            if (!spatialDemoActive) return;
            
            const rect = document.body.getBoundingClientRect();
            userAutoPosition.x = (event.clientX / rect.width) * 100;
            userAutoPosition.y = (event.clientY / rect.height) * 100;
            
            // Update user state visual position
            const userState = document.querySelector('.user-state');
            if (userState) {
                userState.style.left = userAutoPosition.x + '%';
                userState.style.top = userAutoPosition.y + '%';
            }
        }
        
        function updateAIPosition() {
            if (aiIsSeekingUser && spatialDemoActive) {
                // Calculate distance to user
                const dx = userAutoPosition.x - presencePosition.x;
                const dy = userAutoPosition.y - presencePosition.y;
                
                // Move AI zone towards user
                presencePosition.x += dx * 0.02;
                presencePosition.y += dy * 0.02;
                
                // Update AWARENESS center position (blue - AI Adaptation)
                const awarenessCenter = document.getElementById('center1');
                if (awarenessCenter) {
                    awarenessCenter.style.left = presencePosition.x + '%';
                    awarenessCenter.style.top = presencePosition.y + '%';
                }
                
                // Check if AI reached user
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance < 8) {
                    aiIsSeekingUser = false;
                    awarenessCenter.style.animation = '';
                    document.querySelector('.instructions')?.style.setProperty('display', 'block');
                    if (document.querySelector('.instructions')) {
                        document.querySelector('.instructions').textContent = 
                            '🤖 AI Adaptation Complete - Adapting to match your patterns!';
                    }
                }
                
                // Continue animation loop
                if (spatialDemoActive) {
                    requestAnimationFrame(updateAIPosition);
                }
            }
        }
        
        // FRACTAL ACTIVE MEMORY STREAM (based on 03_active_memory_stream.py)
        let activeMemoryStream = [];
        let memoryStreamActive = false;
        
        function startActiveMemoryStream() {
            memoryStreamActive = true;
            
            // Initialize memory stream with HRV insights
            addMemoryEntry("🌀 Fractal manifold visualization activated", "spatial_start");
            addMemoryEntry("🧠 L2 regularized smooth transitions engaged", "neural_processing");
            
            // Start periodic memory updates based on HRV patterns
            setInterval(() => {
                if (memoryStreamActive && spatialDemoActive) {
                    updateMemoryFromHRV();
                }
            }, 2500);
            
            console.log('🧠 Active Memory Stream started - tracking fractal patterns');
        }
        
        function addMemoryEntry(insight, type) {
            const timestamp = new Date().toLocaleTimeString();
            const entry = {
                insight: insight,
                type: type,
                timestamp: timestamp,
                fractalLevel: Math.random() * 3 + 1
            };
            
            activeMemoryStream.push(entry);
            
            // Keep only last 10 entries (like deque with maxlen=100 but optimized for display)
            if (activeMemoryStream.length > 10) {
                activeMemoryStream.shift();
            }
            
            // Visual memory stream update
            updateMemoryStreamVisual();
        }
        
        function updateMemoryFromHRV() {
            // 🚫 CRITICAL: Only process if valid authenticated HRV frame exists
            if (!experience || !experience.isValidFrame(experience.lastHRVFrame)) {
                console.log('🚫 updateMemoryFromHRV: No valid frame - skipping memory update');
                return;
            }
            
            // Use actual HRV data from authenticated frame
            const frame = experience.lastHRVFrame;
            const hrvInsight = `📊 HRV: ${frame.hrv_value}ms | HR: ${frame.heart_rate}bpm | Source: ${frame.source}`;
            addMemoryEntry(hrvInsight, "authenticated_hrv");
        }
        
        function updateMemoryStreamVisual() {
            const memoryStream = document.getElementById('memoryStreamVisual');
            if (!memoryStream) return;
            
            // Update visual gradient based on latest memory entries
            const recentEntries = activeMemoryStream.slice(-3);
            let gradientColors = [];
            
            recentEntries.forEach((entry, index) => {
                const intensity = (index + 1) / recentEntries.length;
                if (entry.type === 'spatial_start') {
                    gradientColors.push(`rgba(0, 255, 200, ${intensity * 0.8})`);
                } else if (entry.type === 'neural_processing') {
                    gradientColors.push(`rgba(255, 100, 200, ${intensity * 0.6})`);
                } else if (entry.type === 'hrv_pattern') {
                    gradientColors.push(`rgba(100, 200, 255, ${intensity * 0.7})`);
                }
            });
            
            if (gradientColors.length > 0) {
                const gradient = `linear-gradient(180deg, ${gradientColors.join(', ')})`;
                memoryStream.style.background = gradient;
            }
        }
        
        function stopActiveMemoryStream() {
            memoryStreamActive = false;
            addMemoryEntry("⏹️ Spatial demo concluded - memory stream archived", "spatial_end");
            
            // Deactivate fractal overlays
            const fractalOverlay = document.getElementById('fractalManifoldOverlay');
            const memoryStream = document.getElementById('memoryStreamVisual');
            fractalOverlay.classList.remove('active');
            memoryStream.classList.remove('active');
            
            console.log('🧠 Active Memory Stream stopped - ' + activeMemoryStream.length + ' entries archived');
        }
        
        // ============ REAL-TIME YOU NODE MAPPING SYSTEM ============
        // Integrates HRV metrics, Soul Metrics, and Your Evolution for dynamic node positioning
        
        let youNodeMappingActive = false;
        let youNodeAnimationFrame = null;
        let currentYouNodeState = {
            position: { x: 300, y: 300 },
            radius: 50,
            pulseSpeed: 1.0,
            amplitude: 0.5,
            color: { hue: 210, saturation: 80, lightness: 50 },
            opacity: 0.8
        };

        // Real-time data collectors
        let latestHRVData = { hrv: 0, heartRate: 72, coherence: 50, breath: 15 };
        let latestSoulMetrics = { coherence: 80, vitality: 80, ethics: 80, narrative: 80 };
        let latestEvolutionData = { empathy: 0.8, creativity: 0.7, resilience: 0.9, focus: 0.7, curiosity: 0.9, compassion: 0.8 };

        function startYouNodeMapping() {
            youNodeMappingActive = true;
            console.log('🎯 Real-time YOU node mapping activated - HRV+Soul+Evolution integration');
            
            // Start continuous mapping updates
            updateYouNodeLoop();
            
            // Set up data listeners for real-time updates
            initializeYouNodeDataListeners();
        }

        function updateYouNodeLoop() {
            if (!youNodeMappingActive) return;
            
            // Calculate new node properties based on real-time data
            updateYouNodeFromData();
            
            // Apply visual updates to the YOU node (center1)
            renderYouNode();
            
            // Continue animation loop
            youNodeAnimationFrame = requestAnimationFrame(updateYouNodeLoop);
        }

        function updateYouNodeFromData() {
            // 🚀 FORCE UNLOCK: Always allow motion when HRV data is live
            console.log('🚀 FORCE MOTION: Always updating YOU node position');
            
            // Δώσε "ορατές" τιμές στο state με ασφαλή defaults
            const baseRadius = 40;
            const hrv = Math.max(0, latestHRVData?.hrv ?? 25);
            const hr  = Math.max(40, latestHRVData?.heartRate ?? 70);
            const coh = Math.max(0, latestHRVData?.coherence ?? 40);

            currentYouNodeState.radius     = baseRadius + (hrv / 50) * 40 + ((latestSoulMetrics?.vitality ?? 70)/100)*25; // πιο μεγάλος
            currentYouNodeState.pulseSpeed = 1.2 + (Math.min(1, (hr - 50) / 70)) * 2.5; // πιο γρήγορος
            currentYouNodeState.amplitude  = 0.6 + (coh / 100) * 1.4;  // διπλάσιο amplitude
            
            // 4. POSITION - Evolution data vector mapping
            const analytical = 1 - latestEvolutionData.empathy; // Inverse of empathy
            const focusCreativity = latestEvolutionData.focus - latestEvolutionData.creativity;
            
            // 🎯 ΣΥΝΑΙΣΘΗΜΑΤΙΚΗ ΧΑΡΤΟΓΡΑΦΗΣΗ - Κίνηση βάσει εσωτερικής κατάστασης
            const screenWidth = window.innerWidth || 800;
            const screenHeight = window.innerHeight || 600;
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            
            // Soul Metrics για συναισθηματική ανάλυση
            const coherence = (latestSoulMetrics?.coherence ?? 50) / 100; // 0-1 (ηρεμία vs άγχος)
            const vitality = (latestSoulMetrics?.vitality ?? 70) / 100;   // 0-1 (στενοχώρια vs χαρά)
            const ethics = (latestSoulMetrics?.ethics ?? 80) / 100;       // 0-1 (ταραχή vs καθαρότητα)
            const narrative = (latestSoulMetrics?.narrative ?? 40) / 100; // 0-1 (εσωτερικότητα vs εξωτερικότητα)
            
            // 💔 ΣΤΕΝΟΧΩΡΙΑ = Χαμηλή vitality → Κίνηση προς το κέντρο (εσωτερική εστίαση)
            // 😊 ΧΑΡΑ = Υψηλή vitality → Κίνηση προς τα άκρα (εξωτερική έκφραση)
            const emotionalRadius = (vitality * 0.7 + coherence * 0.3) * Math.min(screenWidth, screenHeight) * 0.4;
            
            // 🌀 ΑΓΧΟΣ = Χαμηλή coherence → Ταλάντωση/ταραχή
            const anxietyJitter = (1 - coherence) * 50 * Math.sin(Date.now() / 300); // Γρήγορη ταλάντωση
            
            // 🎭 ΣΥΝΑΙΣΘΗΜΑΤΙΚΟΣ ΠΑΛΜΟΣ - Αργή οργανική κίνηση
            const emotionalPhase = Date.now() / 8000; // Αργή περιδίνηση 8 δευτερόλεπτα
            const flowX = Math.sin(emotionalPhase + narrative * Math.PI) * emotionalRadius;
            const flowY = Math.cos(emotionalPhase * 1.1 + ethics * Math.PI) * emotionalRadius * 0.8;
            
            // 🎯 ΤΕΛΙΚΗ ΘΕΣΗ: Κέντρο + συναισθηματική ροή + άγχος
            currentYouNodeState.position.x = centerX + flowX + anxietyJitter;
            currentYouNodeState.position.y = centerY + flowY + anxietyJitter * 0.7;
            
            // 5. COLOR - Vitality (saturation) + Resilience (brightness)
            currentYouNodeState.color.saturation = 50 + (latestSoulMetrics.vitality / 100) * 50;
            currentYouNodeState.color.lightness = 30 + (latestEvolutionData.resilience * 40);
            
            // 6. OPACITY - Overall coherence indicator
            const overallCoherence = (latestHRVData.coherence + latestSoulMetrics.coherence) / 2;
            currentYouNodeState.opacity = 0.6 + (overallCoherence / 100) * 0.4;
        }

        function renderYouNode() {
            const youElement = document.getElementById('userState') 
                              || document.getElementById('center1'); // fallback
            if (!youElement) {
                console.log('🚫 YOU element not found in DOM');
                return;
            }
            // 🚀 FORCE UNLOCK: Never skip rendering

            const state = currentYouNodeState;
            const t = Date.now() / 1000;

            // breath + ΜΕΓΑΛΗ τροχιά για εντονη κίνηση
            const breath = Math.sin(t * state.pulseSpeed * 2 * Math.PI);
            const currentScale = 1 + (breath * state.amplitude * 0.25); // διπλάσιο breathing
            
            // Apply the transform με μεγαλύτερη orbital κίνηση
            const orbit = 25; // τριπλάσια orbital ακτίνα
            const ox = Math.cos(t * 1.5) * orbit; // πιο γρήγορη τροχιά
            const oy = Math.sin(t * 1.5) * orbit;
            
            // Apply position and scale
            const transform = `translate(${state.position.x + ox}px, ${state.position.y + oy}px) scale(${currentScale})`;
            youElement.style.transform = transform;
            youElement.style.opacity = state.opacity;
            
            console.log('🎯 Applied transform:', {
                element: youElement.id,
                transform: transform,
                opacity: state.opacity,
                frozen: window.experience?.motionFrozen,
                hasLiveSignal: window.hasLiveSignal
            });

            youElement.style.left = `${state.position.x + ox - state.radius}px`;
            youElement.style.top  = `${state.position.y + oy - state.radius}px`;
            youElement.style.width  = `${state.radius * 2}px`;
            youElement.style.height = `${state.radius * 2}px`;

            // ΜΟΝΟ ένα transform (με translate για σωστό anchoring)
            youElement.style.transform = `translate(-50%, -50%) scale(${currentScale})`;

            const { hue, saturation, lightness } = state.color;
            youElement.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, ${state.opacity})`;
            youElement.style.boxShadow = `0 0 ${latestSoulMetrics.coherence/4}px hsla(${hue}, ${saturation}%, ${lightness + 20}%, 0.8)`;
            youElement.style.animationDuration = `${2 / state.pulseSpeed}s`;
        }

        function initializeYouNodeDataListeners() {
            // Listen for HRV debug data updates
            if (typeof io !== 'undefined') {
                const debugSocket = io('/');
                debugSocket.on('telemetry', (data) => {
                    // 🎯 UNIFIED SCHEMA: Use hrv_value from telemetry data
                    if (data.hrv_value !== undefined) {
                        latestHRVData.hrv = data.hrv_value || latestHRVData.hrv;
                        console.log('🎯 YOU Node HRV updated:', data.hrv_value + 'ms');
                    }
                    // Legacy support for hrv_debug if present
                    if (data.hrv_debug) {
                        latestHRVData.coherence = data.hrv_debug.coherence || latestHRVData.coherence;
                    }
                });
            }
            
            // Poll for Soul Metrics and Evolution data
            setInterval(() => {
                // ✅ CHECK SIGNAL STATUS BEFORE UPDATING SOUL METRICS
                if (window.experience && !window.experience.hasLiveSignal) {
                    console.log('🚫 NO LIVE SIGNAL - Keeping latestSoulMetrics at baseline');
                    latestSoulMetrics = { coherence: 0, vitality: 0, ethics: 0, narrative: 0 };
                    return;
                }
                
                // Extract from existing system updates
                if (window.experience && window.experience.soulMetrics) {
                    latestSoulMetrics = window.experience.soulMetrics;
                }
                if (window.experience && window.experience.userEvolution) {
                    latestEvolutionData = window.experience.userEvolution.currentPersonality || { empathy:0.5, creativity:0.5, resilience:0.5, focus:0.5, curiosity:0.5, compassion:0.5 };
                }
            }, 500); // Update every 500ms for smooth animation
        }

        function stopYouNodeMapping() {
            youNodeMappingActive = false;
            if (youNodeAnimationFrame) {
                cancelAnimationFrame(youNodeAnimationFrame);
            }
            console.log('🎯 YOU node mapping stopped');
        }

        // ============ LIVE SIGNAL WATCHDOG ============
        // Client-side freeze/unfreeze control based on live data timestamps
        const LIVE_GATE_MS = 6500;     // αν δεν έρθει frame > 6.5s → freeze
        const UNFREEZE_ARM_MS = 1200;  // ελάχιστος χρόνος συνεχόμενων frames πριν unfreeze
        let _lastLiveTs = 0;
        let _lastUnfreezeAttempt = 0;

        function _setLiveState(live) {
            window.hasLiveSignal = live;            // διαβάζεται κι αλλού στο template
            if (window.experience) {
                window.experience.motionFrozen = !live; // ο σκληρός διακόπτης κίνησης
            }
            console.log('🎯 Live State:', live ? '✅ LIVE' : '🚫 FROZEN');
        }

        function liveWatchdogTick() {
            const stale = (performance.now() - _lastLiveTs) > LIVE_GATE_MS;
            if (stale && window.hasLiveSignal) {
                console.log('⏱️ WATCHDOG: No fresh data for ' + Math.round((performance.now() - _lastLiveTs) / 1000) + 's - FREEZING');
                _setLiveState(false);
            }
            setTimeout(liveWatchdogTick, 500);
        }

        // Enhanced syncLiveData with watchdog integration
        async function syncLiveData() {
            try {
                const r = await fetch('/neural/analysis', { cache: 'no-store' });
                const d = await r.json();

                // ενημέρωση collectors (ήδη υπάρχουν στο template)
                window.latestHRVData = {
                    hrv:        d?.hrv?.rmssd ?? 0,
                    heartRate:  d?.hrv?.bpm   ?? 0,
                    coherence:  d?.soul_metrics?.coherence ?? 0,
                    breath:     d?.hrv?.breath ?? 0
                };
                window.latestSoulMetrics   = d?.soul_metrics ?? {};
                window.latestEvolutionData = d?.evolution ?? { empathy:0.5, creativity:0.5, resilience:0.5, focus:0.5, curiosity:0.5, compassion:0.5 };

                // Αν έφτασε "ζωντανό" frame → ανανέωσε timestamp
                const fresh = (window.latestHRVData.heartRate > 0);
                if (fresh) {
                    _lastLiveTs = performance.now();

                    // Αποφυγή τρεμοπαίγματος: θέλουμε ~1.2s συνεχόμενα frames πριν ξεπαγώσουμε
                    if (!window.hasLiveSignal && (performance.now() - _lastUnfreezeAttempt) > UNFREEZE_ARM_MS) {
                        _lastUnfreezeAttempt = performance.now();
                        _setLiveState(true); // UNFREEZE
                        console.log('🔓 Motion UNLOCKED - fresh HRV stream');
                    }
                }

            } catch (e) {
                console.warn('⚠️ syncLiveData failed:', e.message);
                // Αν αποτύχει το fetch, άφησε το watchdog να κάνει freeze όταν λήξει το LIVE_GATE_MS
            }
            setTimeout(syncLiveData, 500);
        }

        // ============ CORE AI INTEGRATION ============
        // Connects the simple Python Core AI module with the frontend panels
        
        let coreAIActive = false;
        let coreAIUpdateInterval = null;
        
        function startCoreAIIntegration() {
            coreAIActive = true;
            console.log('🤖 Core AI Integration starting...');
            
            // 🚦 Update panels with Core AI data every 3 seconds - ONLY WITH LIVE SIGNAL
            coreAIUpdateInterval = setInterval(() => {
                if (coreAIActive) {
                    // 🚦 CHECK LIVE SIGNAL before updating
                    const hasLiveSignal = (this.hasLiveSignal === true);
                    if (!hasLiveSignal) {
                        console.log("🚫 Core AI panels frozen - no live signal");
                        return;
                    }
                    updatePanelsFromCoreAI();
                }
            }, 3000);
            
            // Initial update
            updatePanelsFromCoreAI();
        }
        
        function updatePanelsFromCoreAI() {
            // Process new presence data through Core AI
            fetch('/api/core-ai/process', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Update AWARENESS panel (Blue - center1)
                    updateAwarenessPanel(data.panel_data.awareness);
                    
                    // Update COMPASSION panel (Grey - center2) 
                    updateCompassionPanel(data.panel_data.compassion);
                    
                    console.log('🤖 Core AI panels updated:', data.panel_data.status);
                }
            })
            .catch(error => {
                console.log('Core AI fallback mode:', error.message);
                // Continue with existing enhanced systems on error
            });
        }
        
        function updateAwarenessPanel(awarenessData) {
            // Update Blue AWARENESS center with Core AI data
            const awarenessCenter = document.getElementById('center1');
            if (awarenessCenter && awarenessData) {
                // Visual feedback based on adaptation level
                const adaptationLevel = awarenessData.adaptation_level || 0.5;
                const opacity = 0.6 + (adaptationLevel * 0.4);
                awarenessCenter.style.opacity = opacity;
                
                // Update text if exists
                const awarenessText = awarenessCenter.querySelector('.center-text');
                if (awarenessText) {
                    awarenessText.textContent = `AWARENESS\n${awarenessData.status}`;
                }
                
                // Update any existing panels with Core AI status
                console.log('🔵 AWARENESS updated:', awarenessData.ai_learning);
            }
        }
        
        function updateCompassionPanel(compassionData) {
            // Update Grey COMPASSION center with Core AI data
            const compassionCenter = document.getElementById('center2');
            if (compassionCenter && compassionData) {
                // Visual feedback based on HRV simulation
                const hrvLevel = compassionData.hrv_simulation || 0.5;
                const scale = 1 + (hrvLevel * 0.2);
                compassionCenter.style.transform = `scale(${scale})`;
                
                // Update text if exists
                const compassionText = compassionCenter.querySelector('.center-text');
                if (compassionText) {
                    compassionText.textContent = `COMPASSION\n${compassionData.emotional_state}`;
                }
                
                // Update any existing panels with Core AI status
                console.log('⚪ COMPASSION updated:', compassionData.soul_metrics);
            }
        }
        
        function stopCoreAIIntegration() {
            coreAIActive = false;
            if (coreAIUpdateInterval) {
                clearInterval(coreAIUpdateInterval);
                coreAIUpdateInterval = null;
            }
            console.log('🤖 Core AI Integration stopped');
        }
        
        // 🚦 LIVE SIGNAL CHECK FUNCTION - SELF SUFFICIENT
        function checkLiveSignal() {
            // 1) Αν υπάρχει parent και έχει flag, χρησιμοποίησέ το
            try {
                if (window.parent && window.parent !== window && typeof window.parent.hasLiveSignal !== 'undefined') {
                    return window.parent.hasLiveSignal === true;
                }
            } catch(e) { /* cross-origin guard */ }

            // 2) Αλλιώς, χρησιμοποίησε το δικό μας global που ενημερώνει το self bootstrap
            return window.hasLiveSignal === true;
        }
        
        // Auto-start Core AI integration + Consciousness Parameter Sweep when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Wait a moment for other systems to initialize
            setTimeout(() => {
                startCoreAIIntegration();
                // Start automatic consciousness parameter sweep every 30 seconds
                startAutomaticConsciousnessSweep();
            }, 2000);
        });
        
        // Also start when existing systems initialize
        if (typeof window !== 'undefined') {
            window.addEventListener('load', function() {
                setTimeout(() => {
                    if (!coreAIActive) {
                        startCoreAIIntegration();
                    }
                }, 3000);
            });
        }
        
        // SPATIAL DEMO FUNCTIONS - Missing function implementations
        function toggleSpatialDemo() {
            const btn = document.getElementById('spatialDemoBtn');
            const timer = document.getElementById('spatialTimer');
            
            if (btn.textContent.includes('5min')) {
                // Start 5-minute spatial demo
                btn.textContent = '⏹️ Stop Spatial Demo';
                btn.style.background = 'rgba(239, 68, 68, 0.8)';
                timer.style.display = 'block';
                
                // Start 5-minute countdown
                let timeLeft = 300; // 5 minutes in seconds
                const demoInterval = setInterval(() => {
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    timer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    if (timeLeft <= 0) {
                        clearInterval(demoInterval);
                        btn.textContent = '🚀 5min Spatial Demo';
                        btn.style.background = 'rgba(34, 197, 94, 0.8)';
                        timer.style.display = 'none';
                        console.log('🧬 Spatial demo completed!');
                    }
                    timeLeft--;
                }, 1000);
                
                // Enhance spatial intelligence during demo
                if (typeof experience !== 'undefined') {
                    experience.spatialIntelligence.threshold = 0.5; // More sensitive during demo
                    console.log('🚀 Spatial Demo Active - Enhanced center-loss detection enabled');
                }
                
            } else {
                // Stop demo
                btn.textContent = '🚀 5min Spatial Demo';
                btn.style.background = 'rgba(34, 197, 94, 0.8)';
                timer.style.display = 'none';
                
                // Reset spatial intelligence
                if (typeof experience !== 'undefined') {
                    experience.spatialIntelligence.threshold = 0.7; // Back to normal
                    console.log('⏹️ Spatial Demo Stopped - Normal detection threshold restored');
                }
            }
        }
        
        // Test Consciousness Mapping System - FULL PARAMETER SWEEP
        async function testConsciousnessMapping() {
            console.log('🧠 STARTING FULL CONSCIOUSNESS PARAMETER SWEEP');
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('🔬 Scientific evaluation mode: Complete 2D space traversal');
            
            const button = document.getElementById('testConsciousnessBtn');
            const originalText = button.textContent;
            
            // Show loading state
            button.textContent = '🔄 Starting Full Sweep...';
            button.disabled = true;
            
            try {
                // Call backend parameter sweep API
                const response = await fetch('/api/test/consciousness-parameter-sweep', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        step_size: 0.2,  // 20% steps για πλήρη κάλυψη χωρίς υπερβολικό χρόνο
                        duration_per_step: 600,  // 600ms ανά βήμα για άνετη παρακολούθηση
                        include_soul_metrics: true
                    })
                });
                
                const data = await response.json();
                
                if (data.status === 'consciousness_parameter_sweep_initiated') {
                    console.log('✅ Parameter sweep generated successfully!');
                    console.log(`📊 Coverage: ${data.metadata.total_steps} steps, ${data.metadata.space_coverage}`);
                    console.log(`⏱️ Duration: ${data.metadata.total_duration_ms/1000}s total`);
                    
                    button.textContent = `🧠 Sweeping (${data.metadata.total_steps} steps)`;
                    
                    // Execute the sweep sequence
                    await executeConsciousnessSweep(data.sweep_sequence, data.metadata);
                    
                } else {
                    console.error('❌ Failed to generate parameter sweep:', data);
                    button.textContent = '❌ Sweep Failed';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 3000);
                }
                
            } catch (error) {
                console.error('❌ Error starting consciousness sweep:', error);
                button.textContent = '❌ Network Error';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.disabled = false;
                }, 3000);
            }
        }
        
        // Execute the complete consciousness parameter sweep
        async function executeConsciousnessSweep(sweepSequence, metadata) {
            console.log('🚀 Executing full consciousness parameter sweep...');
            
            const button = document.getElementById('testConsciousnessBtn');
            let currentStep = 0;
            
            for (const step of sweepSequence) {
                // Update button with current progress
                const progress = ((currentStep / metadata.total_steps) * 100).toFixed(0);
                button.textContent = `🧠 Sweep ${progress}% (${currentStep + 1}/${metadata.total_steps})`;
                
                // Create personality from step traits
                const personality = {
                    empathy: step.traits.empathy,
                    creativity: step.traits.curiosity,  // Map curiosity to creativity
                    resilience: 0.5,  // Keep stable
                    focus: step.traits.focus,
                    curiosity: step.traits.curiosity,
                    compassion: step.traits.empathy   // Map empathy to compassion
                };
                
                // Update consciousness mapping
                if (experience && experience.mapConsciousnessToSpace) {
                    const consciousnessPos = experience.mapConsciousnessToSpace(personality);
                    
                    // Override with exact sweep position for precision
                    consciousnessPos.x = step.position.x;
                    consciousnessPos.y = step.position.y;
                    consciousnessPos.state = step.state;
                    consciousnessPos.distanceFromCenter = step.distance_from_center;
                    consciousnessPos.soulMetrics = step.soul_metrics;
                    
                    experience.moveUserToConsciousnessPosition(consciousnessPos);
                    
                    // Log detailed step information
                    if (currentStep % 5 === 0) {  // Log every 5th step to avoid console spam
                        console.log(`🎯 Step ${step.step}: ${step.description}`);
                        console.log(`   Position: (${step.position.x}, ${step.position.y}) | State: ${step.state}`);
                        console.log(`   Soul Metrics: C=${step.soul_metrics.coherence} V=${step.soul_metrics.vitality} E=${step.soul_metrics.ethics} N=${step.soul_metrics.narrative}`);
                    }
                }
                
                currentStep++;
                
                // Wait for step duration
                await new Promise(resolve => setTimeout(resolve, step.duration));
            }
            
            // Completion
            console.log('✅ CONSCIOUSNESS PARAMETER SWEEP COMPLETED!');
            console.log(`📊 Processed ${metadata.total_steps} consciousness states`);
            console.log(`🎯 Covered 100% of 2D consciousness space with ${metadata.coverage} grid`);
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            
            // Restore button and return to current personality
            button.textContent = '✅ Sweep Complete';
            
            // Return to current user personality after 2 seconds
            setTimeout(() => {
                if (experience && experience.userEvolution) {
                    const currentPos = experience.mapConsciousnessToSpace(experience.userEvolution.currentPersonality);
                    experience.moveUserToConsciousnessPosition(currentPos);
                    console.log('🔄 Returned to current personality mapping');
                }
                
                button.textContent = '🧠 Test Consciousness Map';
                button.disabled = false;
            }, 2000);
        }
        
        // AUTOMATIC CONSCIOUSNESS PARAMETER SWEEP SYSTEM
        let automaticSweepActive = false;
        let sweepInterval = null;
        
        function startAutomaticConsciousnessSweep() {
            console.log('🌌 AUTOMATIC CONSCIOUSNESS PARAMETER SWEEP INITIATED');
            console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('🔬 Scientific mode: Continuous 2D space exploration every 30 seconds');
            
            automaticSweepActive = true;
            
            // Run initial sweep immediately
            executeAutomaticParameterSweep();
            
            // Set up recurring sweep every 30 seconds
            sweepInterval = setInterval(() => {
                if (automaticSweepActive) {
                    executeAutomaticParameterSweep();
                }
            }, 30000); // 30 seconds
        }
        
        async function executeAutomaticParameterSweep() {
            if (!automaticSweepActive) return;
            
            // 🚦 CHECK LIVE SIGNAL before sweep
            const hasLiveSignal = (this.hasLiveSignal === true);
            if (!hasLiveSignal) {
                console.log("🚫 Consciousness sweep frozen - no live signal");
                return;
            }
            
            console.log('🧠 EXECUTING AUTOMATIC CONSCIOUSNESS SWEEP...');
            
            try {
                // Call backend parameter sweep API with optimized settings
                const response = await fetch('/api/test/consciousness-parameter-sweep', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        step_size: 0.3,  // Faster sweep για continuous operation
                        duration_per_step: 400,  // Shorter duration per step
                        include_soul_metrics: true
                    })
                });
                
                const data = await response.json();
                
                if (data.status === 'consciousness_parameter_sweep_initiated') {
                    console.log(`✅ Auto-sweep: ${data.metadata.total_steps} steps, ${data.metadata.total_duration_ms/1000}s duration`);
                    
                    // Execute the sweep sequence silently
                    await executeAutomaticSweepSequence(data.sweep_sequence, data.metadata);
                    
                } else {
                    console.log('⚠️ Auto-sweep failed, will retry next cycle');
                }
                
            } catch (error) {
                console.log('⚠️ Auto-sweep network error, continuing normal operation');
            }
        }
        
        // Execute automatic sweep sequence (faster, less logging)
        async function executeAutomaticSweepSequence(sweepSequence, metadata) {
            let currentStep = 0;
            
            for (const step of sweepSequence) {
                if (!automaticSweepActive) break; // Allow stopping mid-sweep
                
                // Create personality from step traits
                const personality = {
                    empathy: step.traits.empathy,
                    creativity: step.traits.curiosity,
                    resilience: 0.5,
                    focus: step.traits.focus,
                    curiosity: step.traits.curiosity,
                    compassion: step.traits.empathy
                };
                
                // Update consciousness mapping
                if (experience && experience.mapConsciousnessToSpace) {
                    const consciousnessPos = experience.mapConsciousnessToSpace(personality);
                    
                    // Override with exact sweep position
                    consciousnessPos.x = step.position.x;
                    consciousnessPos.y = step.position.y;
                    consciousnessPos.state = step.state;
                    consciousnessPos.distanceFromCenter = step.distance_from_center;
                    consciousnessPos.soulMetrics = step.soul_metrics;
                    
                    experience.moveUserToConsciousnessPosition(consciousnessPos);
                    
                    // Minimal logging (every 10th step)
                    if (currentStep % 10 === 0) {
                        console.log(`🎯 Auto-sweep step ${step.step}: ${step.description.substring(0, 30)}...`);
                    }
                }
                
                currentStep++;
                
                // Wait for step duration
                await new Promise(resolve => setTimeout(resolve, step.duration));
            }
            
            console.log(`✅ Auto-sweep completed: ${metadata.total_steps} consciousness states explored`);
            
            // Return to current user personality
            if (experience && experience.userEvolution) {
                setTimeout(() => {
                    const currentPos = experience.mapConsciousnessToSpace(experience.userEvolution.currentPersonality);
                    experience.moveUserToConsciousnessPosition(currentPos);
                }, 1000);
            }
        }
        
        function stopAutomaticConsciousnessSweep() {
            automaticSweepActive = false;
            if (sweepInterval) {
                clearInterval(sweepInterval);
                sweepInterval = null;
            }
            console.log('⏹️ Automatic consciousness parameter sweep stopped');
        }

        // Initialize the experience when page loads
        let experience;
        document.addEventListener('DOMContentLoaded', function() {
            experience = new IntegratedBookCentersExperience();
            console.log('🧬 Book Centers Experience with Spatial Intelligence initialized');
            
            // 🚫 CRITICAL: Start signal monitoring immediately
            experience.startSignalMonitoring();
            
            // 🎯 START NEURAL POLLING for authentic Soul Metrics
            if (experience.startNeuralPolling) {
                experience.startNeuralPolling();
            }
            
            // Start PC TICKR data fetching after a small delay
            setTimeout(() => {
                if (experience && experience.initializePCTickrFetching) {
                    experience.initializePCTickrFetching();
                }
            }, 2000); // Wait 2 seconds for full initialization
        });
        
        // Debug Panel Functions
        let debugPanelVisible = false;
        
        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            debugPanelVisible = !debugPanelVisible;
            
            if (debugPanelVisible) {
                panel.classList.add('visible');
                loadDebugData();
                // Auto-refresh debug data every 1 second for faster HRV response
                window.debugInterval = setInterval(loadDebugData, 1000);
            } else {
                panel.classList.remove('visible');
                if (window.debugInterval) {
                    clearInterval(window.debugInterval);
                }
            }
        }
        
        async function loadDebugData() {
            try {
                const response = await fetch('/debug/hrv');
                const data = await response.json();
                
                // Update debug panel with real data
                document.getElementById('debugWindow').textContent = data.window_secs + 's';
                document.getElementById('debugAlpha').textContent = data.alpha;
                document.getElementById('debugRRCount').textContent = data.n_rr_window;
                document.getElementById('debugRMSSDRaw').textContent = data.rmssd_raw || '--';
                document.getElementById('debugRMSSDWindow').textContent = data.rmssd_window || '--';
                document.getElementById('debugRMSSDSmooth').textContent = data.rmssd_smooth ? data.rmssd_smooth.toFixed(1) : '--';
                document.getElementById('debugSDNNWindow').textContent = data.sdnn_window || '--';
                document.getElementById('debugLastUpdate').textContent = new Date().toLocaleTimeString();
                
            } catch (error) {
                console.error('Error loading debug data:', error);
                document.getElementById('debugStatus').textContent = 'Error';
            }
        }
        
        // Initialize YOU node mapping system on load
        window.addEventListener('load', function() {
            setTimeout(() => {
                startYouNodeMapping();
                console.log('🎯 YOU Node Real-time Mapping: ACTIVATED');
            }, 2000);
        });

        // Auto-activate debug mode if ?debug=1 in URL
        const urlParams = new URLSearchParams(window.location.search);
        const debugMode = urlParams.get('debug') === '1';
        
        if (debugMode) {
            console.log('[ultra] DEBUG=true');
            setTimeout(() => {
                toggleDebugPanel();
                console.log('[ultra] Debug mode activated');
            }, 1000);
        }
        
        // 🚫 OFFLINE KILL-SWITCH
        window.addEventListener('offline', () => {
            if (experience) experience.forceHardDisconnect("OFFLINE");
        });
        
        window.addEventListener('online', () => {
            console.log('🌐 Network restored - but HRV still requires valid frames');
        });
        
        // 🚫 WS lifecycle integrity check (every 1 second)
        setInterval(() => {
            if (experience) {
                // Only trigger disconnect if HRV data exists but both fetch AND websocket failed
                const hasHRVData = experience.systemMetrics.hrv.hrv !== null;
                const hasValidConnection = experience.wsConnected || experience.hasLiveSignal;
                
                if (hasHRVData && !hasValidConnection) {
                    console.log('🔍 HRV present but no valid connection - checking live-data endpoint...');
                    // Give /live-data endpoint a chance to work before forcing disconnect
                    fetch('/neural/analysis').then(response => response.json()).then(data => {
                        if (data.live && data.soul_metrics) {
                            console.log('✅ Live neural data available from endpoint');
                            experience.hasLiveSignal = true;
                        } else {
                            experience.forceHardDisconnect("NO VALID DATA SOURCE");
                        }
                    }).catch(() => {
                        experience.forceHardDisconnect("ENDPOINT_UNREACHABLE");
                    });
                }
            }
        }, 5000); // Check every 5 seconds instead of 1 second
        
        // WebSocket connection for real-time debug data
        let debugSocket = null;
        
        function initializeDebugWebSocket() {
            if (!debugPanelVisible) return;
            
            try {
                debugSocket = io();
                
                // 🚫 WS lifecycle monitoring
                debugSocket.on('connect', () => {
                    console.log('✅ WebSocket connected');
                    if (experience) {
                        experience.wsConnected = true;
                        experience.hasLiveSignal = true; // Also mark as having live signal
                    }
                });
                
                debugSocket.on('disconnect', () => {
                    console.log('🚫 WebSocket disconnected');
                    if (experience) {
                        experience.wsConnected = false;
                        experience.forceHardDisconnect('WS CLOSED');
                    }
                });
                
                // Listen for telemetry updates with strict frame validation
                debugSocket.on('telemetry', (data) => {
                    if (experience) {
                        experience.processIncomingTelemetry(data);
                    }
                });
                
                // 🚫 CRITICAL: Hard disconnect handler for signal loss
                debugSocket.on('hard_disconnect', (data) => {
                    console.log('🚫 HARD DISCONNECT RECEIVED:', data.reason);
                    if (experience && experience.performHardReset) {
                        experience.performHardReset();
                    }
                });
                
                // Send hrv_debug ping event
                debugSocket.emit('hrv_debug', {ping: true});
                console.log('[ultra] Sent hrv_debug ping');
                
                // Listen for hrv_debug responses
                debugSocket.on('hrv_debug_response', function(data) {
                    console.log('[ultra] HRV Debug Response:', data);
                    if (document.getElementById('debugDevice')) {
                        document.getElementById('debugDevice').textContent = data.device || 'Simulation';
                    }
                });
                
                // Listen for telemetry updates (removed duplicate - using telemetry above)
                // debugSocket.on('telemetry_update', function(data) {
                //     if (data.hrv_debug && debugPanelVisible) {
                //         console.log('[ultra] HRV Debug Data:', data.hrv_debug);
                //         updateDebugPanelWithWebSocketData(data.hrv_debug);
                //     }
                // });
                
            } catch (error) {
                console.error('[ultra] WebSocket connection failed:', error);
            }
        }
        
        function updateDebugPanelWithWebSocketData(hrvDebug) {
            try {
                if (hrvDebug.rmssd_raw !== undefined) {
                    document.getElementById('debugRMSSDRaw').textContent = hrvDebug.rmssd_raw ? hrvDebug.rmssd_raw.toFixed(1) + 'ms' : '--';
                }
                if (hrvDebug.rmssd_window !== undefined) {
                    document.getElementById('debugRMSSDWindow').textContent = hrvDebug.rmssd_window ? hrvDebug.rmssd_window.toFixed(1) + 'ms' : '--';
                }
                if (hrvDebug.rmssd_smooth !== undefined) {
                    document.getElementById('debugRMSSDSmooth').textContent = hrvDebug.rmssd_smooth ? hrvDebug.rmssd_smooth.toFixed(1) + 'ms' : '--';
                }
                if (hrvDebug.sdnn_window !== undefined) {
                    document.getElementById('debugSDNNWindow').textContent = hrvDebug.sdnn_window ? hrvDebug.sdnn_window.toFixed(1) + 'ms' : '--';
                }
                if (hrvDebug.n_rr_window !== undefined) {
                    document.getElementById('debugRRCount').textContent = hrvDebug.n_rr_window;
                }
                if (hrvDebug.last_rr && hrvDebug.last_rr.length > 0) {
                    console.log('[ultra] Latest RR intervals:', hrvDebug.last_rr);
                }
                
                document.getElementById('debugLastUpdate').textContent = new Date().toLocaleTimeString();
                
            } catch (error) {
                console.error('[ultra] Error updating debug panel:', error);
            }
        }
        
        // Enhanced toggle function with WebSocket support
        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            debugPanelVisible = !debugPanelVisible;
            
            if (debugPanelVisible) {
                panel.classList.add('visible');
                loadDebugData();
                initializeDebugWebSocket();
                // Auto-refresh debug data every 1 second for faster HRV response
                window.debugInterval = setInterval(loadDebugData, 1000);
                console.log('[ultra] Debug panel visible, WebSocket initialized');
            } else {
                panel.classList.remove('visible');
                if (window.debugInterval) {
                    clearInterval(window.debugInterval);
                }
                if (debugSocket) {
                    debugSocket.disconnect();
                    debugSocket = null;
                }
                console.log('[ultra] Debug panel hidden, WebSocket disconnected');
            }
            
        }
        
        // 🎯 NEURAL POLLING FUNCTION - Direct data sync
        function startNeuralPolling() {
            console.log('🎯 Starting Neural Polling for authentic Soul Metrics');
            
            // Poll every 0.8 seconds for ultra-responsive UI
            window.neuralPollingInterval = setInterval(async () => {
                    try {
                        const response = await fetch('/neural/analysis');
                        
                        if (!response.ok) {
                            console.log('Neural analysis response not OK:', response.status);
                            return;
                        }
                        
                        const data = await response.json();
                        
                        if (data.soul_metrics) {
                            // 🎯 APPLY EMA SMOOTHING to prevent spike-induced inflation
                            const raw = data.soul_metrics;
                            this.smoothedSoul.coherence = this.smoothedSoul.coherence * (1 - this.EMA_ALPHA) + (raw.coherence || 0) * this.EMA_ALPHA;
                            this.smoothedSoul.vitality = this.smoothedSoul.vitality * (1 - this.EMA_ALPHA) + (raw.vitality || 0) * this.EMA_ALPHA;
                            this.smoothedSoul.ethics = this.smoothedSoul.ethics * (1 - this.EMA_ALPHA) + (raw.ethics || 0) * this.EMA_ALPHA;
                            this.smoothedSoul.narrative = this.smoothedSoul.narrative * (1 - this.EMA_ALPHA) + (raw.narrative || 0) * this.EMA_ALPHA;
                            
                            // Update UI with smoothed values to prevent artificial inflation
                            this.systemMetrics.soul.coherence = Math.round(this.smoothedSoul.coherence);
                            this.systemMetrics.soul.vitality = Math.round(this.smoothedSoul.vitality);
                            this.systemMetrics.soul.ethics = Math.round(this.smoothedSoul.ethics);
                            this.systemMetrics.soul.narrative = Math.round(this.smoothedSoul.narrative);
                            
                            console.log('✅ LIVE SOUL METRICS UPDATED (EMA-smoothed):', this.systemMetrics.soul);
                        }
                        
                        if (data.evolution || data.traits) {
                            // Update personality from neural analysis
                            const traits = data.evolution || data.traits;
                            this.userEvolution.currentPersonality = traits;
                        }
                        
                    } catch (error) {
                        console.log('Neural polling error:', error.message);
                    }
                }, 800); // 0.8s for ultra-fast sync
            };
    </script>

<script>
(() => {
  // --- CONFIG ---
  const POLL_MS = 1000;          // fetch κάθε 1s
  const DECAY_MS = 1500;         // βήμα decay
  const DECAY_SOUL = {coherence:4, vitality:5, ethics:3, narrative:4};
  const DECAY_TRAITS = {empathy:2, creativity:2, resilience:1.5, focus:2.5, curiosity:2, compassion:2};

  // --- STATE ---
  let live = false;
  let last = {
    soul: {coherence:30, vitality:25, ethics:40, narrative:35},
    traits: {empathy:.5, creativity:.5, resilience:.5, focus:.5, curiosity:.5, compassion:.5},
    hrv: {rmssd:null, breath:null, coherence:null, focus:null, packet_gap_ms:0}
  };
  let decayTimer = null;
  let renderScheduled = false;
  let poller = null;

  // --- DOM Helpers ---
  function setPct(idTxt, idBar, v){
    const t = document.getElementById(idTxt);
    const b = document.getElementById(idBar);
    if (v==null){ if(t) t.textContent='N/A'; if(b) b.style.width='0%'; return; }
    const p = Math.max(0, Math.min(100, Math.round(v)));
    if (t) t.textContent = p + '%';
    if (b) b.style.width = p + '%';
  }
  function setText(id, val){ const el=document.getElementById(id); if(!el) return; el.textContent = val; }

  // --- UI Apply ---
  function applySoul(m){
    setPct('coherenceScore','coherenceBar', m.coherence);
    setPct('vitalityScore','vitalityBar',   m.vitality);
    setPct('ethicsScore','ethicsBar',       m.ethics);
    setPct('narrativeScore','narrativeBar', m.narrative);
  }
  function applyTraits(t){
    const map = k => ['user',k[0].toUpperCase()+k.slice(1)].join('');
    for (const k of Object.keys(DECAY_TRAITS)){
      const val = Math.max(0, Math.min(100, Math.round((t[k]>1? t[k] : t[k]*100))));
      setPct(map(k)+'Score', map(k)+'Bar', val);
    }
  }
  function applyHRV(h){
    setText('hrvValue',     h.rmssd!=null ? `${(+h.rmssd).toFixed(1)}ms` : 'N/A');
    setText('breathRate',   h.breath!=null ? `${(+h.breath).toFixed(1)}/min` : 'N/A');
    setText('hrvCoherence', h.coherence!=null ? `${Math.round(+h.coherence)}%` : 'N/A');
    setText('focusValue',   h.focus!=null ? `${Math.round(+h.focus)}%` : 'N/A');
  }

  // --- Render queue (ομαλό repaint) ---
  function requestRender(){
    if (renderScheduled) return;
    renderScheduled = true;
    requestAnimationFrame(() => {
      try{
        applySoul(last.soul);
        applyTraits(last.traits);
        applyHRV(last.hrv);
      } finally {
        renderScheduled = false;
      }
    });
  }

  // --- Decay όταν δεν υπάρχει σήμα ---
  function startDecay(){
    if (decayTimer) return;
    decayTimer = setInterval(() => {
      for (const k in DECAY_SOUL){
        last.soul[k] = Math.max(0, (last.soul[k]||0) - DECAY_SOUL[k]);
      }
      for (const k in DECAY_TRAITS){
        const cur = (last.traits[k]||0)*100;
        last.traits[k] = Math.max(0, (cur - DECAY_TRAITS[k]))/100;
      }
      requestRender();
    }, DECAY_MS);
  }
  function stopDecay(){
    if (decayTimer){ clearInterval(decayTimer); decayTimer = null; }
  }

  // --- Poll από backend (single source of truth) ---
  async function poll(){
    try{
      const r = await fetch('/neural/analysis', {cache:'no-store'});
      const j = await r.json();

      live = !!(j && (j.live || j.hasLiveSignal));
      if (live) {
        stopDecay();

        if (j.soul_metrics){
          last.soul.coherence = +j.soul_metrics.coherence || 0;
          last.soul.vitality  = +j.soul_metrics.vitality  || 0;
          last.soul.ethics    = +j.soul_metrics.ethics    || 0;
          last.soul.narrative = +j.soul_metrics.narrative || 0;
        }
        if (j.traits){
          // traits μπορεί να έρχονται 0..1 ή 0..100
          const norm = v => (v>1? v/100 : v);
          for (const k of Object.keys(DECAY_TRAITS)){
            if (k in j.traits) last.traits[k] = Math.max(0, Math.min(1, norm(+j.traits[k])));
          }
        }
        if (j.hrv){
          last.hrv.rmssd       = j.hrv.rmssd ?? j.hrv.hrv ?? null;
          last.hrv.breath      = j.hrv.breath ?? null;
          last.hrv.coherence   = j.hrv.coherence ?? null;
          last.hrv.focus       = j.hrv.focus ?? null;
          last.hrv.packet_gap_ms = j.hrv.packet_gap_ms ?? 0;
        }
      } else {
        startDecay();
      }

      requestRender();
    } catch(e){
      // fetch error -> θεωρούμε προσωρινή απώλεια
      startDecay();
    }
  }

  // --- Boot ---
  function start(){
    // καθάρισε τυχόν παλιά intervals (hot reload)
    if (poller) clearInterval(poller);
    stopDecay();
    poll(); // άμεσο
    poller = setInterval(poll, POLL_MS);
    // αρχικοποίηση UI με baseline
    requestRender();
  }
  function stop(){
    if (poller) clearInterval(poller);
    stopDecay();
  }

  // ξεκινάμε
  start();
  window.addEventListener('beforeunload', stop);
})();
</script>

<script>
  // no-op σε τυχόν "showHelp" κλήσεις
  window.showMetricHelp = function(){};
  // καθάρισε ό,τι υπάρχει ήδη
  (function killTips(){
    document.querySelectorAll('#metricHelp,.metric-tooltip,.soul-tip,.metric-help-popover')
      .forEach(n=>n.remove());
  })();
</script>

<script>
(() => {
  // Βρες / φτιάξε container
  function ensureActiveMemoryUI(){
    let panel = document.querySelector('#activeMemoryPanel');
    if (!panel){
      const sidebar = document.body; // fallback
      panel = document.createElement('div');
      panel.id = 'activeMemoryPanel';
      panel.style.cssText = 'position:fixed;left:16px;bottom:16px;max-width:420px;color:#cfe;font:12px/1.4 system-ui,Segoe UI,sans-serif;z-index:9999';
      panel.innerHTML = `
        <div style="background:#101820;border:1px solid #173e32;box-shadow:0 0 12px rgba(0,255,180,.15);border-radius:8px;overflow:hidden">
          <div style="padding:8px 10px;background:#112;letter-spacing:.2px">
            <b>Active Memory Stream</b>
          </div>
          <div id="activeMemoryList" style="max-height:160px;overflow:auto;padding:8px 10px"></div>
        </div>`;
      sidebar.appendChild(panel);
    }
    if (!document.getElementById('activeMemoryList')){
      const body = document.createElement('div'); body.id='activeMemoryList';
      panel.appendChild(body);
    }
  }

  const mem = { items: [], max: 20, last: null };
  function pushMemory(text){
    ensureActiveMemoryUI();
    const now = new Date();
    const ts  = now.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    mem.items.unshift({ts, text});
    if (mem.items.length > mem.max) mem.items.pop();
    renderMemory();
  }
  function renderMemory(){
    const box = document.getElementById('activeMemoryList'); if (!box) return;
    box.innerHTML = mem.items.map(it => `
      <div style="margin:2px 0;padding:4px 6px;background:#0c1320;border:1px solid #19324d;border-radius:6px">
        <span style="opacity:.7">${it.ts}</span> — ${it.text}
      </div>`).join('');
  }

  // Δημιούργησε απλά "insights" από κάθε neural payload
  const hist = { coh:[], vit:[], foc:[], br:[] };
  function handleNeuralPayload(j){
    const s = j?.soul_metrics || {};
    const h = j?.hrv || {};
    const t = j?.traits || {};

    // ιστορικό για σήμανση
    const coh = +s.coherence || 0;
    const vit = +s.vitality  || 0;
    const foc = +h.focus     || +t.focus || 0;
    const br  = +h.breath    || 0;

    const push = (arr, v, N=15) => { arr.push(v); if(arr.length>N) arr.shift(); };
    push(hist.coh, coh); push(hist.vit, vit); push(hist.foc, foc); push(hist.br, br);

    // απλοί κανόνες
    const avg = a => a.length? a.reduce((x,y)=>x+y,0)/a.length : 0;
    if (hist.coh.length>5){
      const d = coh - avg(hist.coh.slice(0,-1));
      if (d >= 6) pushMemory(`Coherence spike +${d.toFixed(0)}%. Κράτα τον ρυθμό.`);
      if (d <= -6) pushMemory(`Coherence drop ${d.toFixed(0)}%. Δοκίμασε 6 αργές αναπνοές.`);
    }
    if (hist.br.length>5){
      const v = avg(hist.br.slice(-5));
      if (v>0 && v>=9 && v<=12) pushMemory(`Breath stabilized ~${v.toFixed(1)}/min.`);
    }
    if (hist.vit.length>10){
      const dv = vit - avg(hist.vit.slice(0,-1));
      if (dv >= 8) pushMemory(`Vitality ↑ +${dv.toFixed(0)}%. Ενέργεια ανεβαίνει.`);
    }
    if (t.empathy!=null && t.compassion!=null){
      const pros = ((+t.empathy||0) + (+t.compassion||0))/2;
      if (pros>70) pushMemory(`Prosocial state strong (Empathy/Compassion).`);
    }
  }

  // Hook στο poller σου (αν δεν έχεις, χρησιμοποίησε αυτόν τον απλό)
  async function pollNeural(){
    try {
      const r = await fetch('/neural/analysis', {cache:'no-store'});
      const j = await r.json();
      if (j && (j.live || j.hasLiveSignal)) handleNeuralPayload(j);
    } catch(e){ /* ignore */ }
  }
  // Αν έχεις ήδη κεντρικό poll, κάλεσε εκεί το handleNeuralPayload(j).
  // Αλλιώς, άφησε αυτό:
  setInterval(pollNeural, 1500);
})();
</script>


<!-- YOU system disabled -->

<script>
// 🚀 SELF BOOTSTRAP - NO PARENT DEPENDENCY
window.hasLiveSignal = false;

async function pollSignalStatus() {
  try {
    const r = await fetch('/api/signal/status', { cache: 'no-store' });
    const s = await r.json();
    const live = !!s.signal;

    if (live !== window.hasLiveSignal) {
      console.log(live ? '🟢 LIVE SIGNAL DETECTED (self)' : '🔴 LIVE SIGNAL LOST (self)');
    }
    window.hasLiveSignal = live;

    // Συντονισμός με το motion freeze του integrated experience
    if (window.experience) {
      experience.motionFrozen = !live;
    }

    // Προαιρετικά: ξεκίνα/πάγωσε main animations αν υπάρχουν global helpers
    if (live && typeof window.startOrbitLoop === 'function') window.startOrbitLoop();
    if (!live && typeof window.freezeCircle === 'function') window.freezeCircle();
  } catch (e) { /* noop */ }
  setTimeout(pollSignalStatus, 1000);
}

document.addEventListener('DOMContentLoaded', () => {
  console.log('🚀 SELF BOOTSTRAP in integrated template');
  pollSignalStatus();
  
  // 🐕 Initialize WATCHDOG for live signal monitoring
  liveWatchdogTick();
  syncLiveData();
  console.log('🐕 Live Signal Watchdog ACTIVE - 6.5s timeout');
  
  // Σιγουρέψου ότι το animation loop ξεκινά
  if (typeof updateYouNodeLoop === 'function') requestAnimationFrame(updateYouNodeLoop);
});
</script>

<!-- 🎯 PATCH 1: Εκκίνηση animation loop -->
<script>
  document.addEventListener('DOMContentLoaded', () => {
    // ενεργοποίησε το mapping και ξεκίνα το loop ΜΙΑ φορά
    window.youNodeMappingActive = true;
    if (typeof updateYouNodeLoop === 'function' && !window._youLoopStarted) {
      window._youLoopStarted = true;
      requestAnimationFrame(updateYouNodeLoop);
      console.log('🎯 updateYouNodeLoop started');
    }
  });
</script>

<!-- 📡 PATCH 2: Ζωντανό sync δεδομένων -->
<script>
  async function syncLiveData() {
    try {
      const r = await fetch('/neural/analysis', { cache: 'no-store' });
      const d = await r.json();

      // ήδη έχετε αυτά:
      window.latestHRVData = {
        hrv:        d?.hrv?.rmssd ?? 25,
        heartRate:  d?.hrv?.bpm   ?? 70,
        coherence:  d?.soul_metrics?.coherence ?? 40,
        breath:     d?.hrv?.breath ?? 10
      };
      window.latestSoulMetrics = d?.soul_metrics ?? {};
      window.latestEvolutionData = d?.evolution ?? { empathy:0.5, creativity:0.5, resilience:0.5, focus:0.5, curiosity:0.5, compassion:0.5 };

      // 🔓 PATCH: αν φτάνει φρέσκο βιοσήμα, ξεκλείδωσε το freeze
      window._lastHRVts = Date.now();
      const fresh = window.latestHRVData.heartRate > 0;
      if (fresh) {
        window.hasLiveSignal = true;
        if (window.experience) {
          window.experience.motionFrozen = false;
          console.log('🔓 Motion UNLOCKED - fresh HRV data received!');
        }
        // 🚀 FORCE START: Always trigger animation
        if (typeof window.startOrbitLoop === 'function') window.startOrbitLoop();
      }
    } catch(e) { /* ignore */ }
    setTimeout(syncLiveData, 500);
  }
  document.addEventListener('DOMContentLoaded', syncLiveData);
</script>

<!-- 🔧 PATCH 4: Αρχικοποίηση freeze state -->
<script>
  // CRITICAL: Initialize experience object FIRST
  window.experience = window.experience || {};
  window.experience.motionFrozen = false; // 🚀 START UNLOCKED
  console.log('🔧 Experience initialized:', window.experience);
  
  // 🚀 FORCE START ANIMATION LOOP IMMEDIATELY
  setTimeout(() => {
    window.youNodeMappingActive = true;
    if (typeof updateYouNodeLoop === 'function' && !window._youLoopStarted) {
      window._youLoopStarted = true;
      requestAnimationFrame(updateYouNodeLoop);
      console.log('🚀 YOU node animation loop started!');
    }
    if (typeof window.startYouNodeMapping === 'function') {
      window.startYouNodeMapping();
      console.log('🚀 Force started YOU node mapping!');
    }
  }, 1000);
</script>

<!-- 🎯 BIOMETRIC POSITION CONTROL - CSP-Safe External Script -->
<script src="/static/js/biomotion.js" defer></script>

</body>
</html>